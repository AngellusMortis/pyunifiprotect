{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Unofficial UniFi Protect Python API and CLI \u00b6 pyunifiprotect is an unofficial API for UniFi Protect. There is no affiliation with Ubiquiti. This module communicates with UniFi Protect surveillance software installed on a UniFi OS Console such as a Ubiquiti CloudKey+ or UniFi Dream Machine Pro. The API is not documented by Ubiquiti, so there might be misses and/or frequent changes in this module, as Ubiquiti evolves the software. The module is primarily written for the purpose of being used in Home Assistant core integration for UniFi Protect but might be used for other purposes also. Documentation \u00b6 Full documentation for the project . Requirements \u00b6 If you want to install pyunifiprotect natively, the below are the requirements: UniFi Protect version 1.20+ Latest version of library is generally only tested against the two latest minor version. This is either two latest stable versions (such as 1.21.x and 2.0.x) or the latest EA version and stable version (such as 2.2.x EA and 2.1.x). Python 3.9+ POSIX compatible system Library is only test on Linux, specifically the latest Debian version available for the official Python Docker images, but there is no reason the library should not work on any Linux distro or MacOS. ffmpeg ffmpeg is primarily only for streaming audio to Protect cameras, this can be considered a soft requirement Alternatively you can use the provided Docker container , in which case the only requirement is Docker or another OCI compatible orchestrator (such as Kubernetes or podman). Windows is not supported . If you need to use pyunifiprotect on Windows, use Docker Desktop and the provided docker container or WSL . Install \u00b6 From PyPi \u00b6 pyunifiprotect is available on PyPi: Bash 1 pip install pyunifiprotect From Github \u00b6 Bash 1 pip install git+https://github.com/AngellusMortis/pyunifiprotect.git#egg = pyunifiprotect Using Docker Container \u00b6 A Docker container is also provided so you do not need to install/manage Python as well. You can add the following to your .bashrc or similar. Bash 1 2 3 4 5 6 7 8 9 10 function unifi-protect () { docker run --rm -it \\ -e UFP_USERNAME = YOUR_USERNAME_HERE \\ -e UFP_PASSWORD = YOUR_PASSWORD_HERE \\ -e UFP_ADDRESS = YOUR_IP_ADDRESS \\ -e UFP_PORT = 443 \\ -e UFP_SSL_VERIFY = True \\ -e TZ = America/New_York \\ -v $PWD :/data ghcr.io/angellusmortis/pyunifiprotect:latest \" $@ \" } Some notes about the Docker version since it is running inside of a container: You can update at any time using the command docker pull ghcr.io/AngellusMortis/pyunifiprotect:latest Your local current working directory ( $PWD ) will automatically be mounted to /data inside of the container. For commands that output files, this is the only path you can write to and have the file persist. The container supports linux/amd64 and linux/arm64 natively. This means it will also work well on MacOS or Windows using Docker Desktop. For versions of pyunifiprotect before v4.1.5, you need to use the ghcr.io/briis/pyunifiprotect image instead. TZ should be the Olson timezone name for the timezone your UniFi Protect instance is in. For more details on TZ and other environment variables, check the command line docs Quickstart \u00b6 CLI \u00b6 About Ubiquiti SSO accounts Ubiquiti SSO accounts are not supported and actively discouraged from being used. There is no option to use MFA. You are expected to use local access user. pyunifiprotect is not designed to allow you to use your owner account to access the your console or to be used over the public Internet as both pose a security risk. Bash 1 2 3 4 5 6 7 8 9 export UFP_USERNAME = YOUR_USERNAME_HERE export UFP_PASSWORD = YOUR_PASSWORD_HERE export UFP_ADDRESS = YOUR_IP_ADDRESS export UFP_PORT = 443 # change to false if you do not have a valid HTTPS Certificate for your instance export UFP_SSL_VERIFY = True unifi-protect --help unifi-protect nvr Python \u00b6 UniFi Protect itself is 100% async, so as such this library is primarily designed to be used in an async context. The main interface for the library is the pyunifiprotect.ProtectApiClient : Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pyunifiprotect import ProtectApiClient protect = ProtectApiClient ( host , port , username , password , verify_ssl = True ) await protect . update () # this will initialize the protect .bootstrap and open a Websocket connection for updates # get names of your cameras for camera in protect . bootstrap . cameras . values (): print ( camera . name ) # subscribe to Websocket for updates to UFP def callback ( msg : WSSubscriptionMessage ): # do stuff unsub = protect . subscribe_websocket ( callback ) # remove subscription unsub () TODO / Planned / Not Implemented \u00b6 The following the noticeable features are that still missing from pyunifiprotect. All of them are planned for \"some day\" / \"nice to have\" except where noted. Liveview creating/updating/deleting PTZ controls Creating WebRTC streaming connections Backups Device Groups Record Scheduling Battery powered cameras (G3 Battery, Aplify Vision) Camera analytics and live heatmaps Reconfiguring WiFi \"Locate\" feature for Lights/Sensors/Doorlocks The /timeline API endpoint User/Group/Permission management -- partially implemented as users and groups are modeled, just not fleshed out Any strictly UniFi OS feature like managing RAID, creating users, etc. -- Out of Scope. If it ever done, it will be in a separate library that interacts with this one Credits \u00b6 Bjarne Riis ( @briis ) for the original pyunifiprotect package","title":"Home"},{"location":"#unofficial-unifi-protect-python-api-and-cli","text":"pyunifiprotect is an unofficial API for UniFi Protect. There is no affiliation with Ubiquiti. This module communicates with UniFi Protect surveillance software installed on a UniFi OS Console such as a Ubiquiti CloudKey+ or UniFi Dream Machine Pro. The API is not documented by Ubiquiti, so there might be misses and/or frequent changes in this module, as Ubiquiti evolves the software. The module is primarily written for the purpose of being used in Home Assistant core integration for UniFi Protect but might be used for other purposes also.","title":"Unofficial UniFi Protect Python API and CLI"},{"location":"#documentation","text":"Full documentation for the project .","title":"Documentation"},{"location":"#requirements","text":"If you want to install pyunifiprotect natively, the below are the requirements: UniFi Protect version 1.20+ Latest version of library is generally only tested against the two latest minor version. This is either two latest stable versions (such as 1.21.x and 2.0.x) or the latest EA version and stable version (such as 2.2.x EA and 2.1.x). Python 3.9+ POSIX compatible system Library is only test on Linux, specifically the latest Debian version available for the official Python Docker images, but there is no reason the library should not work on any Linux distro or MacOS. ffmpeg ffmpeg is primarily only for streaming audio to Protect cameras, this can be considered a soft requirement Alternatively you can use the provided Docker container , in which case the only requirement is Docker or another OCI compatible orchestrator (such as Kubernetes or podman). Windows is not supported . If you need to use pyunifiprotect on Windows, use Docker Desktop and the provided docker container or WSL .","title":"Requirements"},{"location":"#install","text":"","title":"Install"},{"location":"#from-pypi","text":"pyunifiprotect is available on PyPi: Bash 1 pip install pyunifiprotect","title":"From PyPi"},{"location":"#from-github","text":"Bash 1 pip install git+https://github.com/AngellusMortis/pyunifiprotect.git#egg = pyunifiprotect","title":"From Github"},{"location":"#using-docker-container","text":"A Docker container is also provided so you do not need to install/manage Python as well. You can add the following to your .bashrc or similar. Bash 1 2 3 4 5 6 7 8 9 10 function unifi-protect () { docker run --rm -it \\ -e UFP_USERNAME = YOUR_USERNAME_HERE \\ -e UFP_PASSWORD = YOUR_PASSWORD_HERE \\ -e UFP_ADDRESS = YOUR_IP_ADDRESS \\ -e UFP_PORT = 443 \\ -e UFP_SSL_VERIFY = True \\ -e TZ = America/New_York \\ -v $PWD :/data ghcr.io/angellusmortis/pyunifiprotect:latest \" $@ \" } Some notes about the Docker version since it is running inside of a container: You can update at any time using the command docker pull ghcr.io/AngellusMortis/pyunifiprotect:latest Your local current working directory ( $PWD ) will automatically be mounted to /data inside of the container. For commands that output files, this is the only path you can write to and have the file persist. The container supports linux/amd64 and linux/arm64 natively. This means it will also work well on MacOS or Windows using Docker Desktop. For versions of pyunifiprotect before v4.1.5, you need to use the ghcr.io/briis/pyunifiprotect image instead. TZ should be the Olson timezone name for the timezone your UniFi Protect instance is in. For more details on TZ and other environment variables, check the command line docs","title":"Using Docker Container"},{"location":"#quickstart","text":"","title":"Quickstart"},{"location":"#cli","text":"About Ubiquiti SSO accounts Ubiquiti SSO accounts are not supported and actively discouraged from being used. There is no option to use MFA. You are expected to use local access user. pyunifiprotect is not designed to allow you to use your owner account to access the your console or to be used over the public Internet as both pose a security risk. Bash 1 2 3 4 5 6 7 8 9 export UFP_USERNAME = YOUR_USERNAME_HERE export UFP_PASSWORD = YOUR_PASSWORD_HERE export UFP_ADDRESS = YOUR_IP_ADDRESS export UFP_PORT = 443 # change to false if you do not have a valid HTTPS Certificate for your instance export UFP_SSL_VERIFY = True unifi-protect --help unifi-protect nvr","title":"CLI"},{"location":"#python","text":"UniFi Protect itself is 100% async, so as such this library is primarily designed to be used in an async context. The main interface for the library is the pyunifiprotect.ProtectApiClient : Python 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 from pyunifiprotect import ProtectApiClient protect = ProtectApiClient ( host , port , username , password , verify_ssl = True ) await protect . update () # this will initialize the protect .bootstrap and open a Websocket connection for updates # get names of your cameras for camera in protect . bootstrap . cameras . values (): print ( camera . name ) # subscribe to Websocket for updates to UFP def callback ( msg : WSSubscriptionMessage ): # do stuff unsub = protect . subscribe_websocket ( callback ) # remove subscription unsub ()","title":"Python"},{"location":"#todo-planned-not-implemented","text":"The following the noticeable features are that still missing from pyunifiprotect. All of them are planned for \"some day\" / \"nice to have\" except where noted. Liveview creating/updating/deleting PTZ controls Creating WebRTC streaming connections Backups Device Groups Record Scheduling Battery powered cameras (G3 Battery, Aplify Vision) Camera analytics and live heatmaps Reconfiguring WiFi \"Locate\" feature for Lights/Sensors/Doorlocks The /timeline API endpoint User/Group/Permission management -- partially implemented as users and groups are modeled, just not fleshed out Any strictly UniFi OS feature like managing RAID, creating users, etc. -- Out of Scope. If it ever done, it will be in a separate library that interacts with this one","title":"TODO / Planned / Not Implemented"},{"location":"#credits","text":"Bjarne Riis ( @briis ) for the original pyunifiprotect package","title":"Credits"},{"location":"api/","text":"API Reference \u00b6 API Client ( pyunifiprotect.api ) \u00b6 UniFi Protect Server Wrapper. BaseApiClient \u00b6 api_request_raw ( url : str , method : str = 'get' , require_auth : bool = True , raise_exception : bool = True , ** kwargs : Any ) -> Optional [ bytes ] async \u00b6 Make a request to UniFi Protect API async_connect_ws ( force : bool ) -> None async \u00b6 Connect to Websocket. async_disconnect_ws () -> None async \u00b6 Disconnect from Websocket. authenticate () -> None async \u00b6 Authenticate and get a token. check_ws () -> bool \u00b6 Checks current state of Websocket. close_session () -> None async \u00b6 Closing and delets client session ensure_authenticated () -> None async \u00b6 Ensure we are authenticated. get_session () -> aiohttp . ClientSession async \u00b6 Gets or creates current client session get_websocket () -> Websocket async \u00b6 Gets or creates current Websocket. is_authenticated () -> bool \u00b6 Check to see if we are already authenticated. request ( method : str , url : str , require_auth : bool = False , auto_close : bool = True , ** kwargs : Any ) -> aiohttp . ClientResponse async \u00b6 Make a request to UniFi Protect ProtectApiClient \u00b6 Bases: BaseApiClient Main UFP API Client UniFi Protect is a full async application. \"normal\" use of interacting with it is to call .update() which will initialize the .bootstrap and create a Websocket connection to UFP. This Websocket connection will emit messages that will automatically update the .bootstrap over time. Caling .udpate again (without force ) will verify the integry of the Websocket connection. You can use the .get_ methods to one off pull devices from the UFP API, but should not be used for building an aplication on top of. All objects inside of .bootstrap have a refernce back to the API client so they can use .save_device() and update themselves using their own .set_ methods on the object. Parameters: Name Type Description Default host str UFP hostname / IP address required port int UFP HTTPS port required username str UFP username required password str UFP password required verify_ssl bool Verify HTTPS certificate (default: True ) True session Optional [ aiohttp . ClientSession ] Optional aiohttp session to use (default: generate one) None override_connection_host bool Use host as your connection_host for RTSP stream instead of using the one provided by UniFi Protect. False minimum_score int minimum score for events (default: 0 ) 0 subscribed_models Optional [ Set [ ModelType ]] Model types you want to filter events for WS. You will need to manually check the bootstrap for updates for events that not subscibred. None ignore_stats bool Ignore storage, system, etc. stats/metrics from NVR and cameras (default: false) False debug bool Use full type validation (default: false) False adopt_device ( model_type : ModelType , device_id : str ) -> None async \u00b6 Adopts a device calibrate_lock ( device_id : str ) -> None async \u00b6 Calibrate the doorlock. Door must be open and lock unlocked. clear_tamper_sensor ( device_id : str ) -> None async \u00b6 Clears tamper status for sensor close_lock ( device_id : str ) -> None async \u00b6 Close doorlock (lock) connection_host () -> Union [ IPv4Address , str ] property \u00b6 Connection host to use for generating RTSP URLs get_bootstrap () -> Bootstrap async \u00b6 Gets bootstrap object from UFP instance This is a great alternative if you need metadata about the NVR without connecting to the Websocket get_bridge ( device_id : str ) -> Bridge async \u00b6 Gets a bridge straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.bridges[device_id] get_bridges () -> List [ Bridge ] async \u00b6 Gets the list of bridges straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.bridges get_camera ( device_id : str ) -> Camera async \u00b6 Gets a camera straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.cameras[device_id] get_camera_snapshot ( camera_id : str , width : Optional [ int ] = None , height : Optional [ int ] = None , dt : Optional [ datetime ] = None ) -> Optional [ bytes ] async \u00b6 Gets snapshot for a camera. Datetime of screenshot is approximate. It may be +/- a few seconds. get_camera_video ( camera_id : str , start : datetime , end : datetime , channel_index : int = 0 , validate_channel_id : bool = True , output_file : Optional [ Path ] = None , iterator_callback : Optional [ IteratorCallback ] = None , progress_callback : Optional [ ProgressCallback ] = None , chunk_size : int = 65536 , fps : Optional [ int ] = None ) -> Optional [ bytes ] async \u00b6 Exports MP4 video from a given camera at a specific time. Start/End of video export are approximate. It may be +/- a few seconds. It is recommended to provide a output file or progress callback for larger video clips, otherwise the full video must be downloaded to memory before being written. Providing the fps parameter creates a \"timelapse\" export wtih the given FPS value. Protect app gives the options for 60x (fps=4), 120x (fps=8), 300x (fps=20), and 600x (fps=40). get_cameras () -> List [ Camera ] async \u00b6 Gets the list of cameras straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.cameras get_chime ( device_id : str ) -> Chime async \u00b6 Gets a chime straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.chimes[device_id] get_chimes () -> List [ Chime ] async \u00b6 Gets the list of chimes straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.chimes get_device ( model_type : ModelType , device_id : str , expected_type : Optional [ Type [ ProtectModelWithId ]] = None ) -> ProtectModelWithId async \u00b6 Gets a device give the device model_type and id, converted into Python object get_device_raw ( model_type : ModelType , device_id : str ) -> Dict [ str , Any ] async \u00b6 Gets a raw device give the device model_type and id get_devices ( model_type : ModelType , expected_type : Optional [ Type [ ProtectModel ]] = None ) -> List [ ProtectModel ] async \u00b6 Gets a device list given a model_type, converted into Python objects get_devices_raw ( model_type : ModelType ) -> List [ Dict [ str , Any ]] async \u00b6 Gets a raw device list given a model_type get_doorlock ( device_id : str ) -> Doorlock async \u00b6 Gets a doorlock straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.doorlocks[device_id] get_doorlocks () -> List [ Doorlock ] async \u00b6 Gets the list of doorlocks straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.doorlocks get_event ( event_id : str ) -> Event async \u00b6 Gets an event straight from the NVR. This is a great alternative if the event is no longer in the self.bootstrap.events[event_id] cache get_event_animated_thumbnail ( thumbnail_id : str , width : Optional [ int ] = None , height : Optional [ int ] = None , * , speedup : int = 10 , retry_timeout : int = RETRY_TIMEOUT ) -> Optional [ bytes ] async \u00b6 Gets given animated thumbanil from a given event. Animated thumbnail response is a GIF image. Note: thumbnails / do not generate until after the event ends . Events that last longer then your retry timeout will always return 404. get_event_heatmap ( heatmap_id : str , retry_timeout : int = RETRY_TIMEOUT ) -> Optional [ bytes ] async \u00b6 Gets given heatmap from a given event. Heatmap response is a PNG image. Note: thumbnails / heatmaps do not generate until after the event ends . Events that last longer then your retry timeout will always return None. get_event_smart_detect_track ( event_id : str ) -> SmartDetectTrack async \u00b6 Gets raw Smart Detect Track for a Smart Detection get_event_smart_detect_track_raw ( event_id : str ) -> Dict [ str , Any ] async \u00b6 Gets raw Smart Detect Track for a Smart Detection get_event_thumbnail ( thumbnail_id : str , width : Optional [ int ] = None , height : Optional [ int ] = None , retry_timeout : int = RETRY_TIMEOUT ) -> Optional [ bytes ] async \u00b6 Gets given thumbanail from a given event. Thumbnail response is a JPEG image. Note: thumbnails / heatmaps do not generate until after the event ends . Events that last longer then your retry timeout will always return 404. get_events ( start : Optional [ datetime ] = None , end : Optional [ datetime ] = None , limit : Optional [ int ] = None , types : Optional [ List [ EventType ]] = None , smart_detect_types : Optional [ List [ SmartDetectObjectType ]] = None ) -> List [ Event ] async \u00b6 Same as get_events_raw , except returns actual Event objects instead of raw Python dictionaries filers out non-device events filters out events with too low of a score Parameters: Name Type Description Default start Optional [ datetime ] start time for events None end Optional [ datetime ] end time for events None limit Optional [ int ] max number of events to return None types Optional [ List [ EventType ]] list of EventTypes to get events for None smart_detect_types Optional [ List [ SmartDetectObjectType ]] Filters the Smart detection types for the events None If limit , start and end are not provided, it will default to all events in the last 24 hours. If start is provided, then end or limit must be provided. If end is provided, then start or limit must be provided. Otherwise, you will get a 400 error from UniFi Protect get_events_raw ( start : Optional [ datetime ] = None , end : Optional [ datetime ] = None , limit : Optional [ int ] = None , types : Optional [ List [ EventType ]] = None , smart_detect_types : Optional [ List [ SmartDetectObjectType ]] = None ) -> List [ Dict [ str , Any ]] async \u00b6 Get list of events from Protect Parameters: Name Type Description Default start Optional [ datetime ] start time for events None end Optional [ datetime ] end time for events None limit Optional [ int ] max number of events to return None types Optional [ List [ EventType ]] list of EventTypes to get events for None If limit , start and end are not provided, it will default to all events in the last 24 hours. If start is provided, then end or limit must be provided. If end is provided, then start or limit must be provided. Otherwise, you will get a 400 error from UniFi Protect get_light ( device_id : str ) -> Light async \u00b6 Gets a light straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.lights[device_id] get_lights () -> List [ Light ] async \u00b6 Gets the list of lights straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.lights get_liveview ( device_id : str ) -> Liveview async \u00b6 Gets a liveview straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.liveviews[device_id] get_liveviews () -> List [ Liveview ] async \u00b6 Gets the list of liveviews straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.liveviews get_nvr () -> NVR async \u00b6 Gets an NVR object straight from the NVR. This is a great alternative if you need metadata about the NVR without connecting to the Websocket get_package_camera_snapshot ( camera_id : str , width : Optional [ int ] = None , height : Optional [ int ] = None , dt : Optional [ datetime ] = None ) -> Optional [ bytes ] async \u00b6 Gets snapshot from the package camera. Datetime of screenshot is approximate. It may be +/- a few seconds. get_release_versions () -> set [ Version ] async \u00b6 Get all release versions for UniFi Protect get_sensor ( device_id : str ) -> Sensor async \u00b6 Gets a sensor straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.sensors[device_id] get_sensors () -> List [ Sensor ] async \u00b6 Gets the list of sensors straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.sensors get_viewer ( device_id : str ) -> Viewer async \u00b6 Gets a viewer straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.viewers[device_id] get_viewers () -> List [ Viewer ] async \u00b6 Gets the list of viewers straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.viewers open_lock ( device_id : str ) -> None async \u00b6 Open doorlock (unlock) play_buzzer ( device_id : str ) -> None async \u00b6 Plays chime tones on a chime play_speaker ( device_id : str ) -> None async \u00b6 Plays chime tones on a chime reboot_device ( model_type : ModelType , device_id : str ) -> None async \u00b6 Reboots an adopted device reboot_nvr () -> None async \u00b6 Reboots NVR subscribe_websocket ( ws_callback : Callable [[ WSSubscriptionMessage ], None ]) -> Callable [[], None ] \u00b6 Subscribe to websocket events. Returns a callback that will unsubscribe. unadopt_device ( model_type : ModelType , device_id : str ) -> None async \u00b6 Unadopt/Unmanage adopted device update ( force : bool = False ) -> Optional [ Bootstrap ] async \u00b6 Updates the state of devices, initalizes .bootstrap and connects to UFP Websocket for real time updates You can use the various other get_ methods if you need one off data from UFP update_device ( model_type : ModelType , device_id : str , data : Dict [ str , Any ]) -> None async \u00b6 Sends an update for a device back to UFP USE WITH CAUTION, all possible combinations of updating objects have not been fully tested. May have unexpected side effects. Tested updates have been added a methods on applicable devices. update_nvr ( data : Dict [ str , Any ]) -> None async \u00b6 Sends an update for main UFP NVR device USE WITH CAUTION, all possible combinations of updating objects have not been fully tested. May have unexpected side effects. Tested updates have been added a methods on applicable devices. Data Models ( pyunifiprotect.data ) \u00b6 Bootstrap \u00b6 Bases: ProtectBaseObject get_device_from_id ( device_id : str ) -> ProtectAdoptableDeviceModel | None \u00b6 Retrieve a device from device ID (without knowing model type). get_device_from_mac ( mac : str ) -> ProtectAdoptableDeviceModel | None \u00b6 Retrieve a device from MAC address. get_is_prerelease () -> bool async \u00b6 Get if current version of Protect is a prerelease version. has_media () -> bool property \u00b6 Checks if user can read media for any camera. has_smart_detections () -> bool property \u00b6 Check if any camera has smart detections. recording_start () -> datetime | None property \u00b6 Get earilest recording date. refresh_device ( model_type : ModelType , device_id : str ) -> None async \u00b6 Refresh a device in the bootstrap. Camera \u00b6 Bases: ProtectMotionDeviceModel create_talkback_stream ( content_url : str , ffmpeg_path : Optional [ Path ] = None ) -> TalkbackStream \u00b6 Creates a subprocess to play audio to a camera through its speaker. Requires ffmpeg to use. Parameters: Name Type Description Default content_url str Either a URL accessible by python or a path to a file (ffmepg's -i parameter) required ffmpeg_path Optional [ Path ] Optional path to ffmpeg binary None Use either await stream.run_until_complete() or await stream.start() to start subprocess command after getting the stream. .play_audio() is a helper that wraps this method and automatically runs the subprocess as well get_package_snapshot ( width : Optional [ int ] = None , height : Optional [ int ] = None , dt : Optional [ datetime ] = None ) -> Optional [ bytes ] async \u00b6 Gets snapshot from the package camera. Datetime of screenshot is approximate. It may be +/- a few seconds. get_snapshot ( width : Optional [ int ] = None , height : Optional [ int ] = None , dt : Optional [ datetime ] = None ) -> Optional [ bytes ] async \u00b6 Gets snapshot for camera. Datetime of screenshot is approximate. It may be +/- a few seconds. get_video ( start : datetime , end : datetime , channel_index : int = 0 , output_file : Optional [ Path ] = None , iterator_callback : Optional [ IteratorCallback ] = None , progress_callback : Optional [ ProgressCallback ] = None , chunk_size : int = 65536 , fps : Optional [ int ] = None ) -> Optional [ bytes ] async \u00b6 Exports MP4 video from a given camera at a specific time. Start/End of video export are approximate. It may be +/- a few seconds. It is recommended to provide a output file or progress callback for larger video clips, otherwise the full video must be downloaded to memory before being written. Providing the fps parameter creates a \"timelapse\" export wtih the given FPS value. Protect app gives the options for 60x (fps=4), 120x (fps=8), 300x (fps=20), and 600x (fps=40). is_face_detection_on () -> bool property \u00b6 Is Face Detection available and enabled (camera will produce face smart detection events)? is_license_plate_detection_on () -> bool property \u00b6 Is License Plate Detection available and enabled (camera will produce face license plate detection events)? is_motion_detection_on () -> bool property \u00b6 Is Motion Detection available and enabled (camera will produce motion events)? is_package_detection_on () -> bool property \u00b6 Is Package Detection available and enabled (camera will produce package smart detection events)? is_person_detection_on () -> bool property \u00b6 Is Person Detection available and enabled (camera will produce person smart detection events)? is_pet_detection_on () -> bool property \u00b6 Is Pet Detection available and enabled (camera will produce pet smart detection events)? is_recording_enabled () -> bool property \u00b6 Is recording footage/events from the camera enabled? If recording is not enabled, cameras will not produce any footage, thumbnails, motion/smart detection events. is_smoke_detection_on () -> bool property \u00b6 Is Smoke Detection available and enabled (camera will produce smoke smart detection events)? is_vehicle_detection_on () -> bool property \u00b6 Is Vehicle Detection available and enabled (camera will produce vehicle smart detection events)? play_audio ( content_url : str , ffmpeg_path : Optional [ Path ] = None , blocking : bool = True ) -> None async \u00b6 Plays audio to a camera through its speaker. Requires ffmpeg to use. Parameters: Name Type Description Default content_url str Either a URL accessible by python or a path to a file (ffmepg's -i parameter) required ffmpeg_path Optional [ Path ] Optional path to ffmpeg binary None blocking bool Awaits stream completion and logs stdout/stderr True set_camera_zoom ( level : int ) -> None async \u00b6 Sets zoom level for camera set_chime_duration ( duration : timedelta | float | int ) -> None async \u00b6 Sets chime duration for doorbell. Requires camera to be a doorbell set_chime_type ( chime_type : ChimeType ) -> None async \u00b6 Sets chime type for doorbell. Requires camera to be a doorbell set_face_detection ( enabled : bool ) -> None async \u00b6 Toggles face smart detection. Requires camera to have smart detection set_hdr ( enabled : bool ) -> None async \u00b6 Sets HDR (High Dynamic Range) on camera set_ir_led_model ( mode : IRLEDMode ) -> None async \u00b6 Sets IR LED mode on camera set_lcd_text ( text_type : Optional [ DoorbellMessageType ], text : Optional [ str ] = None , reset_at : Union [ None , datetime , DEFAULT_TYPE ] = None ) -> None async \u00b6 Sets doorbell LCD text. Requires camera to be doorbell set_license_plate_detection ( enabled : bool ) -> None async \u00b6 Toggles license plate smart detection. Requires camera to have smart detection set_mic_volume ( level : int ) -> None async \u00b6 Sets the mic sensitivity level on camera set_motion_detection ( enabled : bool ) -> None async \u00b6 Sets motion detection on camera set_osd_bitrate ( enabled : bool ) -> None async \u00b6 Sets whether camera bitrate is in the On Screen Display set_osd_date ( enabled : bool ) -> None async \u00b6 Sets whether current date is in the On Screen Display set_osd_logo ( enabled : bool ) -> None async \u00b6 Sets whether the UniFi logo is in the On Screen Display set_osd_name ( enabled : bool ) -> None async \u00b6 Sets whether camera name is in the On Screen Display set_package_detection ( enabled : bool ) -> None async \u00b6 Toggles package smart detection. Requires camera to have smart detection set_person_detection ( enabled : bool ) -> None async \u00b6 Toggles person smart detection. Requires camera to have smart detection set_pet_detection ( enabled : bool ) -> None async \u00b6 Toggles pet smart detection. Requires camera to have smart detection set_privacy ( enabled : bool , mic_level : Optional [ int ] = None , recording_mode : Optional [ RecordingMode ] = None ) -> None async \u00b6 Adds/removes a privacy zone that blacks out the whole camera set_recording_mode ( mode : RecordingMode ) -> None async \u00b6 Sets recording mode on camera set_smart_audio_detect_types ( types : List [ SmartDetectAudioType ]) -> None async \u00b6 Sets current enabled smart audio detection types. Requires camera to have smart detection set_smart_detect_types ( types : List [ SmartDetectObjectType ]) -> None async \u00b6 Sets current enabled smart detection types. Requires camera to have smart detection set_smoke_detection ( enabled : bool ) -> None async \u00b6 Toggles smoke_cmonx smart detection. Requires camera to have smart detection set_speaker_volume ( level : int ) -> None async \u00b6 Sets the speaker sensitivity level on camera. Requires camera to have speakers set_status_light ( enabled : bool ) -> None async \u00b6 Sets status indicicator light on camera set_system_sounds ( enabled : bool ) -> None async \u00b6 Sets system sound playback through speakers. Requires camera to have speakers set_vehicle_detection ( enabled : bool ) -> None async \u00b6 Toggles vehicle smart detection. Requires camera to have smart detection set_video_mode ( mode : VideoMode ) -> None async \u00b6 Sets video mode on camera set_wdr_level ( level : int ) -> None async \u00b6 Sets WDR (Wide Dynamic Range) on camera stop_audio () -> None async \u00b6 Stop currently playing audio. wait_until_audio_completes () -> None async \u00b6 Awaits stream completion of audio and logs stdout/stderr. Chime \u00b6 Bases: ProtectAdoptableDeviceModel add_camera ( camera : Camera ) -> None async \u00b6 Adds new paired camera to chime cameras () -> List [ Camera ] property \u00b6 Paired Cameras for chime play () -> None async \u00b6 Plays chime tone play_buzzer () -> None async \u00b6 Plays chime buzzer remove_camera ( camera : Camera ) -> None async \u00b6 Removes paired camera from chime set_volume ( level : int ) -> None async \u00b6 Sets the volume on chime Doorlock \u00b6 Bases: ProtectAdoptableDeviceModel calibrate () -> None async \u00b6 Calibrate the doorlock. Door must be open and lock unlocked. camera () -> Optional [ Camera ] property \u00b6 Paired Camera will always be none if no camera is paired close_lock () -> None async \u00b6 Close doorlock (lock) open_lock () -> None async \u00b6 Open doorlock (unlock) set_auto_close_time ( duration : timedelta ) -> None async \u00b6 Sets the auto-close time for doorlock. 0 seconds = disabled. set_paired_camera ( camera : Optional [ Camera ]) -> None async \u00b6 Sets the camera paired with the sensor set_status_light ( enabled : bool ) -> None async \u00b6 Sets the status indicator light for the doorlock Event \u00b6 Bases: ProtectModelWithId get_animated_thumbnail ( width : Optional [ int ] = None , height : Optional [ int ] = None , * , speedup : int = 10 ) -> Optional [ bytes ] async \u00b6 Gets animated thumbnail for event get_heatmap () -> Optional [ bytes ] async \u00b6 Gets heatmap for event get_smart_detect_track () -> SmartDetectTrack async \u00b6 Gets smart detect track for given smart detect event. If event is not a smart detect event, it will raise a BadRequest get_smart_detect_zones () -> Dict [ int , CameraZone ] async \u00b6 Gets the triggering zones for the smart detection get_thumbnail ( width : Optional [ int ] = None , height : Optional [ int ] = None ) -> Optional [ bytes ] async \u00b6 Gets thumbnail for event get_video ( channel_index : int = 0 , output_file : Optional [ Path ] = None , iterator_callback : Optional [ IteratorCallback ] = None , progress_callback : Optional [ ProgressCallback ] = None , chunk_size : int = 65536 ) -> Optional [ bytes ] async \u00b6 Get the MP4 video clip for this given event Parameters: Name Type Description Default channel_index int index of CameraChannel on the camera to use to retrieve video from 0 Will raise an exception if event does not have a camera, end time or the channel index is wrong. FixSizeOrderedDict \u00b6 Bases: dict [ KT , VT ] A fixed size ordered dict. __init__ ( * args : Any , max_size : int = 0 , ** kwargs : Any ) -> None \u00b6 Create the FixSizeOrderedDict. __setitem__ ( key : KT , value : VT ) -> None \u00b6 Set an update up to the max size. Light \u00b6 Bases: ProtectMotionDeviceModel camera () -> Optional [ Camera ] property \u00b6 Paired Camera will always be none if no camera is paired set_duration ( duration : timedelta ) -> None async \u00b6 Sets motion sensitivity set_led_level ( led_level : int ) -> None async \u00b6 Sets the LED level for the light set_light ( enabled : bool , led_level : Optional [ int ] = None ) -> None async \u00b6 Force turns on/off the light set_light_settings ( mode : LightModeType , enable_at : Optional [ LightModeEnableType ] = None , duration : Optional [ timedelta ] = None , sensitivity : Optional [ int ] = None ) -> None async \u00b6 Updates various Light settings. Parameters: Name Type Description Default mode LightModeType Light trigger mode required enable_at Optional [ LightModeEnableType ] Then the light automatically turns on by itself None duration Optional [ timedelta ] How long the light should remain on after motion, must be timedelta between 15s and 900s None sensitivity Optional [ int ] PIR Motion sensitivity None set_paired_camera ( camera : Optional [ Camera ]) -> None async \u00b6 Sets the camera paired with the light set_sensitivity ( sensitivity : int ) -> None async \u00b6 Sets motion sensitivity set_status_light ( enabled : bool ) -> None async \u00b6 Sets the status indicator light for the light Liveview \u00b6 Bases: ProtectModelWithId owner () -> Optional [ User ] property \u00b6 Owner of liveview. Will be none if the user only has read only access and it was not made by their user. NVR \u00b6 Bases: ProtectDeviceModel add_custom_doorbell_message ( message : str ) -> None async \u00b6 Adds custom doorbell message get_is_prerelease () -> bool async \u00b6 Get if current version of Protect is a prerelease version. reboot () -> None async \u00b6 Reboots the NVR remove_custom_doorbell_message ( message : str ) -> None async \u00b6 Removes custom doorbell message set_analytics ( value : AnalyticsOption ) -> None async \u00b6 Sets analytics collection for NVR set_anonymous_analytics ( enabled : bool ) -> None async \u00b6 Enables or disables anonymous analystics for NVR set_default_doorbell_message ( message : str ) -> None async \u00b6 Sets default doorbell message set_default_reset_timeout ( timeout : timedelta ) -> None async \u00b6 Sets the default message reset timeout set_insights ( enabled : bool ) -> None async \u00b6 Sets analytics collection for NVR update_all_messages () -> None \u00b6 Updates doorbell_settings.all_messages after adding/removing custom message vault_cameras () -> List [ Camera ] property \u00b6 Vault Cameras for NVR ProtectAdoptableDeviceModel \u00b6 Bases: ProtectDeviceModel adopt ( name : Optional [ str ] = None ) -> None async \u00b6 Adopts a device get_changed () -> Dict [ str , Any ] \u00b6 Gets dictionary of all changed fields is_adopted_by_us () -> bool property \u00b6 Verifies device is adopted and controlled by this NVR. protect_url () -> str property \u00b6 UFP Web app URL for this device reboot () -> None async \u00b6 Reboots an adopted device set_ssh ( enabled : bool ) -> None async \u00b6 Sets ssh status for protect device unadopt () -> None async \u00b6 Unadopt/Unmanage adopted device ProtectBaseObject \u00b6 Bases: BaseModel Base class for building Python objects from UniFi Protect JSON. Provides .unifi_dict_to_dict to convert UFP JSON to a more Pythonic formatted dict (camel case to snake case) Add attrs with matching Pyhonic name and they will automatically be populated from the UFP JSON if passed in to the constructer Provides .unifi_dict to convert object back into UFP JSON __init__ ( api : Optional [ ProtectApiClient ] = None , ** data : Any ) -> None \u00b6 Base class for creating Python objects from UFP JSON data. Use the static method .from_unifi_dict() to create objects from UFP JSON data from then the main class constructor. api () -> ProtectApiClient property \u00b6 ProtectApiClient that the UFP object was created with. If no API Client was passed in time of creation, will raise BadRequest from_unifi_dict ( api : Optional [ ProtectApiClient ] = None , ** data : Any ) -> ProtectObject classmethod \u00b6 Main constructor for ProtectBaseObject Parameters: Name Type Description Default api Optional [ ProtectApiClient ] Optional reference to the ProtectAPIClient that created generated the UFP JSON None **data Any decoded UFP JSON {} api is is expected as a @property . If it is None and accessed, a BadRequest will be raised. API can be used for saving updates for the Protect object or fetching references to other objects (cameras, users, etc.) unifi_dict ( data : Optional [ Dict [ str , Any ]] = None , exclude : Optional [ Set [ str ]] = None ) -> Dict [ str , Any ] \u00b6 Can either convert current Python object into UFP JSON dict or take the output of a .dict() call and convert it. Remaps items from ._get_unifi_remaps() in reverse Converts snake_case to camelCase Automatically removes any ProtectApiClient instances that might still be in the data Automatically calls .unifi_dict() for any UFP Python objects that are detected Parameters: Name Type Description Default data Optional [ Dict [ str , Any ]] Optional output of .dict() for the Python object. If None , will call .dict first None exclude Optional [ Set [ str ]] Optional set of fields to exclude from convert. Useful for subclassing and having custom processing for dumping to UFP JSON data. None unifi_dict_to_dict ( data : Dict [ str , Any ]) -> Dict [ str , Any ] classmethod \u00b6 Takes a decoded UFP JSON dict and converts it into a Python dict Remaps items from ._get_unifi_remaps() Converts camelCase keys to snake_case keys Injects ProtectAPIClient into any child UFP object Dicts Runs .unifi_dict_to_dict for any child UFP objects Parameters: Name Type Description Default data Dict [ str , Any ] decoded UFP JSON dict required update_from_dict ( data : Dict [ str , Any ]) -> ProtectObject \u00b6 Updates current object from a cleaned UFP JSON dict ProtectDeviceModel \u00b6 Bases: ProtectModelWithId set_name ( name : str | None ) -> None async \u00b6 Sets name for the device ProtectModel \u00b6 Bases: ProtectBaseObject Base class for UFP objects with a modelKey attr. Provides .from_unifi_dict() static helper method for automatically decoding a modelKey object into the correct UFP object and type ProtectModelWithId \u00b6 Bases: ProtectModel emit_message ( updated : Dict [ str , Any ]) -> None async \u00b6 Emites fake WS message for ProtectApiClient to process. queue_update ( callback : Callable [[], None ]) -> None async \u00b6 Queues a device update. This allows aggregating devices updates so if multiple ones come in all at once, they can be combined in a single PATCH. revert_changes () -> None \u00b6 Reverts current changes to device and resets it back to initial state save_device ( force_emit : bool = False , revert_on_fail : bool = True ) -> None async \u00b6 Generates a diff for unsaved changed on the device and sends them back to UFP USE WITH CAUTION, updates all fields for the current object that have been changed. May have unexpected side effects. Tested updates have been added a methods on applicable devices. Parameters: Name Type Description Default force_emit bool Emit a fake UFP WS message. Should only be use for when UFP does not properly emit a WS message False ProtectWSPayloadFormat \u00b6 Bases: int , enum . Enum Websocket Payload formats. Sensor \u00b6 Bases: ProtectAdoptableDeviceModel camera () -> Optional [ Camera ] property \u00b6 Paired Camera will always be none if no camera is paired clear_tamper () -> None async \u00b6 Clears tamper status for sensor remove_humidity_safe_range () -> None async \u00b6 Removes the humidity safe range for the sensor remove_light_safe_range () -> None async \u00b6 Removes the light safe range for the sensor remove_temperature_safe_range () -> None async \u00b6 Removes the temperature safe range for the sensor set_alarm_status ( enabled : bool ) -> None async \u00b6 Sets the alarm detection type for the sensor set_humidity_safe_range ( low : float , high : float ) -> None async \u00b6 Sets the humidity safe range for the sensor set_humidity_status ( enabled : bool ) -> None async \u00b6 Sets the humidity detection type for the sensor set_light_safe_range ( low : float , high : float ) -> None async \u00b6 Sets the light safe range for the sensor set_light_status ( enabled : bool ) -> None async \u00b6 Sets the light detection type for the sensor set_motion_sensitivity ( sensitivity : int ) -> None async \u00b6 Sets the motion sensitivity for the sensor set_motion_status ( enabled : bool ) -> None async \u00b6 Sets the motion detection type for the sensor set_mount_type ( mount_type : MountType ) -> None async \u00b6 Sets current mount type for sensor set_paired_camera ( camera : Optional [ Camera ]) -> None async \u00b6 Sets the camera paired with the sensor set_status_light ( enabled : bool ) -> None async \u00b6 Sets the status indicator light for the sensor set_temperature_safe_range ( low : float , high : float ) -> None async \u00b6 Sets the temperature safe range for the sensor set_temperature_status ( enabled : bool ) -> None async \u00b6 Sets the temperature detection type for the sensor User \u00b6 Bases: ProtectModelWithId can ( model : ModelType , node : PermissionNode , obj : Optional [ ProtectModelWithId ] = None ) -> bool \u00b6 Checks if a user can do a specific action groups () -> List [ Group ] property \u00b6 Groups the user is in Will always be empty if the user only has read only access. Viewer \u00b6 Bases: ProtectAdoptableDeviceModel set_liveview ( liveview : Liveview ) -> None async \u00b6 Sets the liveview current set for the viewer Parameters: Name Type Description Default liveview Liveview The liveview you want to set required create_from_unifi_dict ( data : Dict [ str , Any ], api : Optional [ ProtectApiClient ] = None , klass : Optional [ Type [ ProtectModel ]] = None ) -> ProtectModel \u00b6 Helper method to read the modelKey from a UFP JSON dict and convert to currect Python class. Will raise DataDecodeError if the modelKey is for an unknown object. Exceptions ( pyunifiprotect.exception ) \u00b6 BadRequest \u00b6 Bases: ClientError Invalid request from API Client ClientError \u00b6 Bases: UnifiProtectError Base Class for all other UniFi Protect client errors DataDecodeError \u00b6 Bases: UnifiProtectError Exception raised when trying to decode a UniFi Protect object Invalid \u00b6 Bases: ClientError Invalid return from Authorization Request. NotAuthorized \u00b6 Bases: PermissionError , BadRequest Wrong username, password or permission error. NvrError \u00b6 Bases: ClientError Other error. StreamError \u00b6 Bases: UnifiProtectError Expcetion raised when trying to stream content UnifiProtectError \u00b6 Bases: Exception Base class for all other UniFi Protect errors WSDecodeError \u00b6 Bases: UnifiProtectError Exception raised when decoding Websocket packet WSEncodeError \u00b6 Bases: UnifiProtectError Exception raised when encoding Websocket packet Stream ( pyunifiprotect.stream ) \u00b6 Utils ( pyunifiprotect.utils ) \u00b6 convert_smart_audio_types ( items : Iterable [ str ]) -> List [ SmartDetectAudioType ] \u00b6 Converts list of str into SmartDetectAudioType. Any unknown values will be ignored and logged. convert_smart_types ( items : Iterable [ str ]) -> List [ SmartDetectObjectType ] \u00b6 Converts list of str into SmartDetectObjectType. Any unknown values will be ignored and logged. convert_unifi_data ( value : Any , field : ModelField ) -> Any \u00b6 Converts value from UFP data into pydantic field class convert_video_modes ( items : Iterable [ str ]) -> List [ VideoMode ] \u00b6 Converts list of str into VideoMode. Any unknown values will be ignored and logged. decode_token_cookie ( token_cookie : Morsel [ str ]) -> Dict [ str , Any ] | None \u00b6 Decode a token cookie if it is still valid. format_datetime ( dt : Optional [ datetime ], default : Optional [ str ] = None ) -> Optional [ str ] \u00b6 Formats a datetime object in a consisent format format_duration ( duration : timedelta ) -> str \u00b6 Formats a timedelta as a string. from_js_time ( num : Union [ int , float , str , datetime ]) -> datetime \u00b6 Converts Javascript timestamp to Python datetime get_local_timezone () -> tzinfo \u00b6 Gets Olson timezone name for localizing datetimes is_debug () -> bool \u00b6 Returns if debug ENV is on (True) local_datetime ( dt : datetime | None = None ) -> datetime \u00b6 Returns datetime in local timezone process_datetime ( data : Dict [ str , Any ], key : str ) -> Optional [ datetime ] \u00b6 Extracts datetime object from Protect dictionary serialize_coord ( coord : CoordType ) -> Union [ int , float ] \u00b6 Serializes UFP zone coordinate serialize_dict ( data : Dict [ str , Any ]) -> Dict [ str , Any ] \u00b6 Serializes UFP data dict serialize_list ( items : Iterable [ Any ]) -> List [ Any ] \u00b6 Serializes UFP data list serialize_point ( point : Tuple [ CoordType , CoordType ]) -> List [ Union [ int , float ]] \u00b6 Serializes UFP zone coordinate point serialize_unifi_obj ( value : Any ) -> Any \u00b6 Serializes UFP data set_debug () -> None \u00b6 Sets ENV variable for UFP_DEBUG to on (True) set_no_debug () -> None \u00b6 Sets ENV variable for UFP_DEBUG to off (False) to_camel_case ( name : str ) -> str \u00b6 Converts string to camelCase to_js_time ( dt : datetime | int | None ) -> Optional [ int ] \u00b6 Converts Python datetime to Javascript timestamp to_ms ( duration : Optional [ timedelta ]) -> Optional [ int ] \u00b6 Converts python timedelta to Milliseconds to_snake_case ( name : str ) -> str \u00b6 Converts string to snake_case Websocket ( pyunifiprotect.websocket ) \u00b6 Websocket \u00b6 connect () -> bool async \u00b6 Connect the websocket. disconnect () -> None async \u00b6 Disconnect the websocket. is_connected () -> bool property \u00b6 Is Websocket connected reconnect () -> bool async \u00b6 Reconnect the websocket. subscribe ( ws_callback : Callable [[ WSMessage ], None ]) -> Callable [[], None ] \u00b6 Subscribe to raw websocket messages. Returns a callback that will unsubscribe.","title":"API Reference"},{"location":"api/#api-reference","text":"","title":"API Reference"},{"location":"api/#api-client-pyunifiprotectapi","text":"UniFi Protect Server Wrapper.","title":"API Client (pyunifiprotect.api)"},{"location":"api/#pyunifiprotect.api.BaseApiClient","text":"","title":"BaseApiClient"},{"location":"api/#pyunifiprotect.api.BaseApiClient.api_request_raw","text":"Make a request to UniFi Protect API","title":"api_request_raw()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.async_connect_ws","text":"Connect to Websocket.","title":"async_connect_ws()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.async_disconnect_ws","text":"Disconnect from Websocket.","title":"async_disconnect_ws()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.authenticate","text":"Authenticate and get a token.","title":"authenticate()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.check_ws","text":"Checks current state of Websocket.","title":"check_ws()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.close_session","text":"Closing and delets client session","title":"close_session()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.ensure_authenticated","text":"Ensure we are authenticated.","title":"ensure_authenticated()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.get_session","text":"Gets or creates current client session","title":"get_session()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.get_websocket","text":"Gets or creates current Websocket.","title":"get_websocket()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.is_authenticated","text":"Check to see if we are already authenticated.","title":"is_authenticated()"},{"location":"api/#pyunifiprotect.api.BaseApiClient.request","text":"Make a request to UniFi Protect","title":"request()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient","text":"Bases: BaseApiClient Main UFP API Client UniFi Protect is a full async application. \"normal\" use of interacting with it is to call .update() which will initialize the .bootstrap and create a Websocket connection to UFP. This Websocket connection will emit messages that will automatically update the .bootstrap over time. Caling .udpate again (without force ) will verify the integry of the Websocket connection. You can use the .get_ methods to one off pull devices from the UFP API, but should not be used for building an aplication on top of. All objects inside of .bootstrap have a refernce back to the API client so they can use .save_device() and update themselves using their own .set_ methods on the object. Parameters: Name Type Description Default host str UFP hostname / IP address required port int UFP HTTPS port required username str UFP username required password str UFP password required verify_ssl bool Verify HTTPS certificate (default: True ) True session Optional [ aiohttp . ClientSession ] Optional aiohttp session to use (default: generate one) None override_connection_host bool Use host as your connection_host for RTSP stream instead of using the one provided by UniFi Protect. False minimum_score int minimum score for events (default: 0 ) 0 subscribed_models Optional [ Set [ ModelType ]] Model types you want to filter events for WS. You will need to manually check the bootstrap for updates for events that not subscibred. None ignore_stats bool Ignore storage, system, etc. stats/metrics from NVR and cameras (default: false) False debug bool Use full type validation (default: false) False","title":"ProtectApiClient"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.adopt_device","text":"Adopts a device","title":"adopt_device()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.calibrate_lock","text":"Calibrate the doorlock. Door must be open and lock unlocked.","title":"calibrate_lock()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.clear_tamper_sensor","text":"Clears tamper status for sensor","title":"clear_tamper_sensor()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.close_lock","text":"Close doorlock (lock)","title":"close_lock()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.connection_host","text":"Connection host to use for generating RTSP URLs","title":"connection_host()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_bootstrap","text":"Gets bootstrap object from UFP instance This is a great alternative if you need metadata about the NVR without connecting to the Websocket","title":"get_bootstrap()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_bridge","text":"Gets a bridge straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.bridges[device_id]","title":"get_bridge()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_bridges","text":"Gets the list of bridges straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.bridges","title":"get_bridges()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_camera","text":"Gets a camera straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.cameras[device_id]","title":"get_camera()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_camera_snapshot","text":"Gets snapshot for a camera. Datetime of screenshot is approximate. It may be +/- a few seconds.","title":"get_camera_snapshot()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_camera_video","text":"Exports MP4 video from a given camera at a specific time. Start/End of video export are approximate. It may be +/- a few seconds. It is recommended to provide a output file or progress callback for larger video clips, otherwise the full video must be downloaded to memory before being written. Providing the fps parameter creates a \"timelapse\" export wtih the given FPS value. Protect app gives the options for 60x (fps=4), 120x (fps=8), 300x (fps=20), and 600x (fps=40).","title":"get_camera_video()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_cameras","text":"Gets the list of cameras straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.cameras","title":"get_cameras()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_chime","text":"Gets a chime straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.chimes[device_id]","title":"get_chime()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_chimes","text":"Gets the list of chimes straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.chimes","title":"get_chimes()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_device","text":"Gets a device give the device model_type and id, converted into Python object","title":"get_device()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_device_raw","text":"Gets a raw device give the device model_type and id","title":"get_device_raw()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_devices","text":"Gets a device list given a model_type, converted into Python objects","title":"get_devices()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_devices_raw","text":"Gets a raw device list given a model_type","title":"get_devices_raw()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_doorlock","text":"Gets a doorlock straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.doorlocks[device_id]","title":"get_doorlock()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_doorlocks","text":"Gets the list of doorlocks straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.doorlocks","title":"get_doorlocks()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_event","text":"Gets an event straight from the NVR. This is a great alternative if the event is no longer in the self.bootstrap.events[event_id] cache","title":"get_event()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_event_animated_thumbnail","text":"Gets given animated thumbanil from a given event. Animated thumbnail response is a GIF image. Note: thumbnails / do not generate until after the event ends . Events that last longer then your retry timeout will always return 404.","title":"get_event_animated_thumbnail()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_event_heatmap","text":"Gets given heatmap from a given event. Heatmap response is a PNG image. Note: thumbnails / heatmaps do not generate until after the event ends . Events that last longer then your retry timeout will always return None.","title":"get_event_heatmap()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_event_smart_detect_track","text":"Gets raw Smart Detect Track for a Smart Detection","title":"get_event_smart_detect_track()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_event_smart_detect_track_raw","text":"Gets raw Smart Detect Track for a Smart Detection","title":"get_event_smart_detect_track_raw()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_event_thumbnail","text":"Gets given thumbanail from a given event. Thumbnail response is a JPEG image. Note: thumbnails / heatmaps do not generate until after the event ends . Events that last longer then your retry timeout will always return 404.","title":"get_event_thumbnail()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_events","text":"Same as get_events_raw , except returns actual Event objects instead of raw Python dictionaries filers out non-device events filters out events with too low of a score Parameters: Name Type Description Default start Optional [ datetime ] start time for events None end Optional [ datetime ] end time for events None limit Optional [ int ] max number of events to return None types Optional [ List [ EventType ]] list of EventTypes to get events for None smart_detect_types Optional [ List [ SmartDetectObjectType ]] Filters the Smart detection types for the events None If limit , start and end are not provided, it will default to all events in the last 24 hours. If start is provided, then end or limit must be provided. If end is provided, then start or limit must be provided. Otherwise, you will get a 400 error from UniFi Protect","title":"get_events()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_events_raw","text":"Get list of events from Protect Parameters: Name Type Description Default start Optional [ datetime ] start time for events None end Optional [ datetime ] end time for events None limit Optional [ int ] max number of events to return None types Optional [ List [ EventType ]] list of EventTypes to get events for None If limit , start and end are not provided, it will default to all events in the last 24 hours. If start is provided, then end or limit must be provided. If end is provided, then start or limit must be provided. Otherwise, you will get a 400 error from UniFi Protect","title":"get_events_raw()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_light","text":"Gets a light straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.lights[device_id]","title":"get_light()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_lights","text":"Gets the list of lights straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.lights","title":"get_lights()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_liveview","text":"Gets a liveview straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.liveviews[device_id]","title":"get_liveview()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_liveviews","text":"Gets the list of liveviews straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.liveviews","title":"get_liveviews()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_nvr","text":"Gets an NVR object straight from the NVR. This is a great alternative if you need metadata about the NVR without connecting to the Websocket","title":"get_nvr()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_package_camera_snapshot","text":"Gets snapshot from the package camera. Datetime of screenshot is approximate. It may be +/- a few seconds.","title":"get_package_camera_snapshot()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_release_versions","text":"Get all release versions for UniFi Protect","title":"get_release_versions()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_sensor","text":"Gets a sensor straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.sensors[device_id]","title":"get_sensor()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_sensors","text":"Gets the list of sensors straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.sensors","title":"get_sensors()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_viewer","text":"Gets a viewer straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.viewers[device_id]","title":"get_viewer()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.get_viewers","text":"Gets the list of viewers straight from the NVR. The websocket is connected and running, you likely just want to use self.bootstrap.viewers","title":"get_viewers()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.open_lock","text":"Open doorlock (unlock)","title":"open_lock()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.play_buzzer","text":"Plays chime tones on a chime","title":"play_buzzer()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.play_speaker","text":"Plays chime tones on a chime","title":"play_speaker()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.reboot_device","text":"Reboots an adopted device","title":"reboot_device()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.reboot_nvr","text":"Reboots NVR","title":"reboot_nvr()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.subscribe_websocket","text":"Subscribe to websocket events. Returns a callback that will unsubscribe.","title":"subscribe_websocket()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.unadopt_device","text":"Unadopt/Unmanage adopted device","title":"unadopt_device()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.update","text":"Updates the state of devices, initalizes .bootstrap and connects to UFP Websocket for real time updates You can use the various other get_ methods if you need one off data from UFP","title":"update()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.update_device","text":"Sends an update for a device back to UFP USE WITH CAUTION, all possible combinations of updating objects have not been fully tested. May have unexpected side effects. Tested updates have been added a methods on applicable devices.","title":"update_device()"},{"location":"api/#pyunifiprotect.api.ProtectApiClient.update_nvr","text":"Sends an update for main UFP NVR device USE WITH CAUTION, all possible combinations of updating objects have not been fully tested. May have unexpected side effects. Tested updates have been added a methods on applicable devices.","title":"update_nvr()"},{"location":"api/#data-models-pyunifiprotectdata","text":"","title":"Data Models (pyunifiprotect.data)"},{"location":"api/#pyunifiprotect.data.Bootstrap","text":"Bases: ProtectBaseObject","title":"Bootstrap"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.get_device_from_id","text":"Retrieve a device from device ID (without knowing model type).","title":"get_device_from_id()"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.get_device_from_mac","text":"Retrieve a device from MAC address.","title":"get_device_from_mac()"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.get_is_prerelease","text":"Get if current version of Protect is a prerelease version.","title":"get_is_prerelease()"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.has_media","text":"Checks if user can read media for any camera.","title":"has_media()"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.has_smart_detections","text":"Check if any camera has smart detections.","title":"has_smart_detections()"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.recording_start","text":"Get earilest recording date.","title":"recording_start()"},{"location":"api/#pyunifiprotect.data.bootstrap.Bootstrap.refresh_device","text":"Refresh a device in the bootstrap.","title":"refresh_device()"},{"location":"api/#pyunifiprotect.data.Camera","text":"Bases: ProtectMotionDeviceModel","title":"Camera"},{"location":"api/#pyunifiprotect.data.devices.Camera.create_talkback_stream","text":"Creates a subprocess to play audio to a camera through its speaker. Requires ffmpeg to use. Parameters: Name Type Description Default content_url str Either a URL accessible by python or a path to a file (ffmepg's -i parameter) required ffmpeg_path Optional [ Path ] Optional path to ffmpeg binary None Use either await stream.run_until_complete() or await stream.start() to start subprocess command after getting the stream. .play_audio() is a helper that wraps this method and automatically runs the subprocess as well","title":"create_talkback_stream()"},{"location":"api/#pyunifiprotect.data.devices.Camera.get_package_snapshot","text":"Gets snapshot from the package camera. Datetime of screenshot is approximate. It may be +/- a few seconds.","title":"get_package_snapshot()"},{"location":"api/#pyunifiprotect.data.devices.Camera.get_snapshot","text":"Gets snapshot for camera. Datetime of screenshot is approximate. It may be +/- a few seconds.","title":"get_snapshot()"},{"location":"api/#pyunifiprotect.data.devices.Camera.get_video","text":"Exports MP4 video from a given camera at a specific time. Start/End of video export are approximate. It may be +/- a few seconds. It is recommended to provide a output file or progress callback for larger video clips, otherwise the full video must be downloaded to memory before being written. Providing the fps parameter creates a \"timelapse\" export wtih the given FPS value. Protect app gives the options for 60x (fps=4), 120x (fps=8), 300x (fps=20), and 600x (fps=40).","title":"get_video()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_face_detection_on","text":"Is Face Detection available and enabled (camera will produce face smart detection events)?","title":"is_face_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_license_plate_detection_on","text":"Is License Plate Detection available and enabled (camera will produce face license plate detection events)?","title":"is_license_plate_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_motion_detection_on","text":"Is Motion Detection available and enabled (camera will produce motion events)?","title":"is_motion_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_package_detection_on","text":"Is Package Detection available and enabled (camera will produce package smart detection events)?","title":"is_package_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_person_detection_on","text":"Is Person Detection available and enabled (camera will produce person smart detection events)?","title":"is_person_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_pet_detection_on","text":"Is Pet Detection available and enabled (camera will produce pet smart detection events)?","title":"is_pet_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_recording_enabled","text":"Is recording footage/events from the camera enabled? If recording is not enabled, cameras will not produce any footage, thumbnails, motion/smart detection events.","title":"is_recording_enabled()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_smoke_detection_on","text":"Is Smoke Detection available and enabled (camera will produce smoke smart detection events)?","title":"is_smoke_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.is_vehicle_detection_on","text":"Is Vehicle Detection available and enabled (camera will produce vehicle smart detection events)?","title":"is_vehicle_detection_on()"},{"location":"api/#pyunifiprotect.data.devices.Camera.play_audio","text":"Plays audio to a camera through its speaker. Requires ffmpeg to use. Parameters: Name Type Description Default content_url str Either a URL accessible by python or a path to a file (ffmepg's -i parameter) required ffmpeg_path Optional [ Path ] Optional path to ffmpeg binary None blocking bool Awaits stream completion and logs stdout/stderr True","title":"play_audio()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_camera_zoom","text":"Sets zoom level for camera","title":"set_camera_zoom()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_chime_duration","text":"Sets chime duration for doorbell. Requires camera to be a doorbell","title":"set_chime_duration()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_chime_type","text":"Sets chime type for doorbell. Requires camera to be a doorbell","title":"set_chime_type()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_face_detection","text":"Toggles face smart detection. Requires camera to have smart detection","title":"set_face_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_hdr","text":"Sets HDR (High Dynamic Range) on camera","title":"set_hdr()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_ir_led_model","text":"Sets IR LED mode on camera","title":"set_ir_led_model()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_lcd_text","text":"Sets doorbell LCD text. Requires camera to be doorbell","title":"set_lcd_text()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_license_plate_detection","text":"Toggles license plate smart detection. Requires camera to have smart detection","title":"set_license_plate_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_mic_volume","text":"Sets the mic sensitivity level on camera","title":"set_mic_volume()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_motion_detection","text":"Sets motion detection on camera","title":"set_motion_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_osd_bitrate","text":"Sets whether camera bitrate is in the On Screen Display","title":"set_osd_bitrate()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_osd_date","text":"Sets whether current date is in the On Screen Display","title":"set_osd_date()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_osd_logo","text":"Sets whether the UniFi logo is in the On Screen Display","title":"set_osd_logo()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_osd_name","text":"Sets whether camera name is in the On Screen Display","title":"set_osd_name()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_package_detection","text":"Toggles package smart detection. Requires camera to have smart detection","title":"set_package_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_person_detection","text":"Toggles person smart detection. Requires camera to have smart detection","title":"set_person_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_pet_detection","text":"Toggles pet smart detection. Requires camera to have smart detection","title":"set_pet_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_privacy","text":"Adds/removes a privacy zone that blacks out the whole camera","title":"set_privacy()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_recording_mode","text":"Sets recording mode on camera","title":"set_recording_mode()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_smart_audio_detect_types","text":"Sets current enabled smart audio detection types. Requires camera to have smart detection","title":"set_smart_audio_detect_types()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_smart_detect_types","text":"Sets current enabled smart detection types. Requires camera to have smart detection","title":"set_smart_detect_types()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_smoke_detection","text":"Toggles smoke_cmonx smart detection. Requires camera to have smart detection","title":"set_smoke_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_speaker_volume","text":"Sets the speaker sensitivity level on camera. Requires camera to have speakers","title":"set_speaker_volume()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_status_light","text":"Sets status indicicator light on camera","title":"set_status_light()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_system_sounds","text":"Sets system sound playback through speakers. Requires camera to have speakers","title":"set_system_sounds()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_vehicle_detection","text":"Toggles vehicle smart detection. Requires camera to have smart detection","title":"set_vehicle_detection()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_video_mode","text":"Sets video mode on camera","title":"set_video_mode()"},{"location":"api/#pyunifiprotect.data.devices.Camera.set_wdr_level","text":"Sets WDR (Wide Dynamic Range) on camera","title":"set_wdr_level()"},{"location":"api/#pyunifiprotect.data.devices.Camera.stop_audio","text":"Stop currently playing audio.","title":"stop_audio()"},{"location":"api/#pyunifiprotect.data.devices.Camera.wait_until_audio_completes","text":"Awaits stream completion of audio and logs stdout/stderr.","title":"wait_until_audio_completes()"},{"location":"api/#pyunifiprotect.data.Chime","text":"Bases: ProtectAdoptableDeviceModel","title":"Chime"},{"location":"api/#pyunifiprotect.data.devices.Chime.add_camera","text":"Adds new paired camera to chime","title":"add_camera()"},{"location":"api/#pyunifiprotect.data.devices.Chime.cameras","text":"Paired Cameras for chime","title":"cameras()"},{"location":"api/#pyunifiprotect.data.devices.Chime.play","text":"Plays chime tone","title":"play()"},{"location":"api/#pyunifiprotect.data.devices.Chime.play_buzzer","text":"Plays chime buzzer","title":"play_buzzer()"},{"location":"api/#pyunifiprotect.data.devices.Chime.remove_camera","text":"Removes paired camera from chime","title":"remove_camera()"},{"location":"api/#pyunifiprotect.data.devices.Chime.set_volume","text":"Sets the volume on chime","title":"set_volume()"},{"location":"api/#pyunifiprotect.data.Doorlock","text":"Bases: ProtectAdoptableDeviceModel","title":"Doorlock"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.calibrate","text":"Calibrate the doorlock. Door must be open and lock unlocked.","title":"calibrate()"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.camera","text":"Paired Camera will always be none if no camera is paired","title":"camera()"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.close_lock","text":"Close doorlock (lock)","title":"close_lock()"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.open_lock","text":"Open doorlock (unlock)","title":"open_lock()"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.set_auto_close_time","text":"Sets the auto-close time for doorlock. 0 seconds = disabled.","title":"set_auto_close_time()"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.set_paired_camera","text":"Sets the camera paired with the sensor","title":"set_paired_camera()"},{"location":"api/#pyunifiprotect.data.devices.Doorlock.set_status_light","text":"Sets the status indicator light for the doorlock","title":"set_status_light()"},{"location":"api/#pyunifiprotect.data.Event","text":"Bases: ProtectModelWithId","title":"Event"},{"location":"api/#pyunifiprotect.data.nvr.Event.get_animated_thumbnail","text":"Gets animated thumbnail for event","title":"get_animated_thumbnail()"},{"location":"api/#pyunifiprotect.data.nvr.Event.get_heatmap","text":"Gets heatmap for event","title":"get_heatmap()"},{"location":"api/#pyunifiprotect.data.nvr.Event.get_smart_detect_track","text":"Gets smart detect track for given smart detect event. If event is not a smart detect event, it will raise a BadRequest","title":"get_smart_detect_track()"},{"location":"api/#pyunifiprotect.data.nvr.Event.get_smart_detect_zones","text":"Gets the triggering zones for the smart detection","title":"get_smart_detect_zones()"},{"location":"api/#pyunifiprotect.data.nvr.Event.get_thumbnail","text":"Gets thumbnail for event","title":"get_thumbnail()"},{"location":"api/#pyunifiprotect.data.nvr.Event.get_video","text":"Get the MP4 video clip for this given event Parameters: Name Type Description Default channel_index int index of CameraChannel on the camera to use to retrieve video from 0 Will raise an exception if event does not have a camera, end time or the channel index is wrong.","title":"get_video()"},{"location":"api/#pyunifiprotect.data.FixSizeOrderedDict","text":"Bases: dict [ KT , VT ] A fixed size ordered dict.","title":"FixSizeOrderedDict"},{"location":"api/#pyunifiprotect.data.types.FixSizeOrderedDict.__init__","text":"Create the FixSizeOrderedDict.","title":"__init__()"},{"location":"api/#pyunifiprotect.data.types.FixSizeOrderedDict.__setitem__","text":"Set an update up to the max size.","title":"__setitem__()"},{"location":"api/#pyunifiprotect.data.Light","text":"Bases: ProtectMotionDeviceModel","title":"Light"},{"location":"api/#pyunifiprotect.data.devices.Light.camera","text":"Paired Camera will always be none if no camera is paired","title":"camera()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_duration","text":"Sets motion sensitivity","title":"set_duration()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_led_level","text":"Sets the LED level for the light","title":"set_led_level()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_light","text":"Force turns on/off the light","title":"set_light()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_light_settings","text":"Updates various Light settings. Parameters: Name Type Description Default mode LightModeType Light trigger mode required enable_at Optional [ LightModeEnableType ] Then the light automatically turns on by itself None duration Optional [ timedelta ] How long the light should remain on after motion, must be timedelta between 15s and 900s None sensitivity Optional [ int ] PIR Motion sensitivity None","title":"set_light_settings()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_paired_camera","text":"Sets the camera paired with the light","title":"set_paired_camera()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_sensitivity","text":"Sets motion sensitivity","title":"set_sensitivity()"},{"location":"api/#pyunifiprotect.data.devices.Light.set_status_light","text":"Sets the status indicator light for the light","title":"set_status_light()"},{"location":"api/#pyunifiprotect.data.Liveview","text":"Bases: ProtectModelWithId","title":"Liveview"},{"location":"api/#pyunifiprotect.data.nvr.Liveview.owner","text":"Owner of liveview. Will be none if the user only has read only access and it was not made by their user.","title":"owner()"},{"location":"api/#pyunifiprotect.data.NVR","text":"Bases: ProtectDeviceModel","title":"NVR"},{"location":"api/#pyunifiprotect.data.nvr.NVR.add_custom_doorbell_message","text":"Adds custom doorbell message","title":"add_custom_doorbell_message()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.get_is_prerelease","text":"Get if current version of Protect is a prerelease version.","title":"get_is_prerelease()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.reboot","text":"Reboots the NVR","title":"reboot()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.remove_custom_doorbell_message","text":"Removes custom doorbell message","title":"remove_custom_doorbell_message()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.set_analytics","text":"Sets analytics collection for NVR","title":"set_analytics()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.set_anonymous_analytics","text":"Enables or disables anonymous analystics for NVR","title":"set_anonymous_analytics()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.set_default_doorbell_message","text":"Sets default doorbell message","title":"set_default_doorbell_message()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.set_default_reset_timeout","text":"Sets the default message reset timeout","title":"set_default_reset_timeout()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.set_insights","text":"Sets analytics collection for NVR","title":"set_insights()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.update_all_messages","text":"Updates doorbell_settings.all_messages after adding/removing custom message","title":"update_all_messages()"},{"location":"api/#pyunifiprotect.data.nvr.NVR.vault_cameras","text":"Vault Cameras for NVR","title":"vault_cameras()"},{"location":"api/#pyunifiprotect.data.ProtectAdoptableDeviceModel","text":"Bases: ProtectDeviceModel","title":"ProtectAdoptableDeviceModel"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.adopt","text":"Adopts a device","title":"adopt()"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.get_changed","text":"Gets dictionary of all changed fields","title":"get_changed()"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.is_adopted_by_us","text":"Verifies device is adopted and controlled by this NVR.","title":"is_adopted_by_us()"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.protect_url","text":"UFP Web app URL for this device","title":"protect_url()"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.reboot","text":"Reboots an adopted device","title":"reboot()"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.set_ssh","text":"Sets ssh status for protect device","title":"set_ssh()"},{"location":"api/#pyunifiprotect.data.base.ProtectAdoptableDeviceModel.unadopt","text":"Unadopt/Unmanage adopted device","title":"unadopt()"},{"location":"api/#pyunifiprotect.data.ProtectBaseObject","text":"Bases: BaseModel Base class for building Python objects from UniFi Protect JSON. Provides .unifi_dict_to_dict to convert UFP JSON to a more Pythonic formatted dict (camel case to snake case) Add attrs with matching Pyhonic name and they will automatically be populated from the UFP JSON if passed in to the constructer Provides .unifi_dict to convert object back into UFP JSON","title":"ProtectBaseObject"},{"location":"api/#pyunifiprotect.data.base.ProtectBaseObject.__init__","text":"Base class for creating Python objects from UFP JSON data. Use the static method .from_unifi_dict() to create objects from UFP JSON data from then the main class constructor.","title":"__init__()"},{"location":"api/#pyunifiprotect.data.base.ProtectBaseObject.api","text":"ProtectApiClient that the UFP object was created with. If no API Client was passed in time of creation, will raise BadRequest","title":"api()"},{"location":"api/#pyunifiprotect.data.base.ProtectBaseObject.from_unifi_dict","text":"Main constructor for ProtectBaseObject Parameters: Name Type Description Default api Optional [ ProtectApiClient ] Optional reference to the ProtectAPIClient that created generated the UFP JSON None **data Any decoded UFP JSON {} api is is expected as a @property . If it is None and accessed, a BadRequest will be raised. API can be used for saving updates for the Protect object or fetching references to other objects (cameras, users, etc.)","title":"from_unifi_dict()"},{"location":"api/#pyunifiprotect.data.base.ProtectBaseObject.unifi_dict","text":"Can either convert current Python object into UFP JSON dict or take the output of a .dict() call and convert it. Remaps items from ._get_unifi_remaps() in reverse Converts snake_case to camelCase Automatically removes any ProtectApiClient instances that might still be in the data Automatically calls .unifi_dict() for any UFP Python objects that are detected Parameters: Name Type Description Default data Optional [ Dict [ str , Any ]] Optional output of .dict() for the Python object. If None , will call .dict first None exclude Optional [ Set [ str ]] Optional set of fields to exclude from convert. Useful for subclassing and having custom processing for dumping to UFP JSON data. None","title":"unifi_dict()"},{"location":"api/#pyunifiprotect.data.base.ProtectBaseObject.unifi_dict_to_dict","text":"Takes a decoded UFP JSON dict and converts it into a Python dict Remaps items from ._get_unifi_remaps() Converts camelCase keys to snake_case keys Injects ProtectAPIClient into any child UFP object Dicts Runs .unifi_dict_to_dict for any child UFP objects Parameters: Name Type Description Default data Dict [ str , Any ] decoded UFP JSON dict required","title":"unifi_dict_to_dict()"},{"location":"api/#pyunifiprotect.data.base.ProtectBaseObject.update_from_dict","text":"Updates current object from a cleaned UFP JSON dict","title":"update_from_dict()"},{"location":"api/#pyunifiprotect.data.ProtectDeviceModel","text":"Bases: ProtectModelWithId","title":"ProtectDeviceModel"},{"location":"api/#pyunifiprotect.data.base.ProtectDeviceModel.set_name","text":"Sets name for the device","title":"set_name()"},{"location":"api/#pyunifiprotect.data.ProtectModel","text":"Bases: ProtectBaseObject Base class for UFP objects with a modelKey attr. Provides .from_unifi_dict() static helper method for automatically decoding a modelKey object into the correct UFP object and type","title":"ProtectModel"},{"location":"api/#pyunifiprotect.data.ProtectModelWithId","text":"Bases: ProtectModel","title":"ProtectModelWithId"},{"location":"api/#pyunifiprotect.data.base.ProtectModelWithId.emit_message","text":"Emites fake WS message for ProtectApiClient to process.","title":"emit_message()"},{"location":"api/#pyunifiprotect.data.base.ProtectModelWithId.queue_update","text":"Queues a device update. This allows aggregating devices updates so if multiple ones come in all at once, they can be combined in a single PATCH.","title":"queue_update()"},{"location":"api/#pyunifiprotect.data.base.ProtectModelWithId.revert_changes","text":"Reverts current changes to device and resets it back to initial state","title":"revert_changes()"},{"location":"api/#pyunifiprotect.data.base.ProtectModelWithId.save_device","text":"Generates a diff for unsaved changed on the device and sends them back to UFP USE WITH CAUTION, updates all fields for the current object that have been changed. May have unexpected side effects. Tested updates have been added a methods on applicable devices. Parameters: Name Type Description Default force_emit bool Emit a fake UFP WS message. Should only be use for when UFP does not properly emit a WS message False","title":"save_device()"},{"location":"api/#pyunifiprotect.data.ProtectWSPayloadFormat","text":"Bases: int , enum . Enum Websocket Payload formats.","title":"ProtectWSPayloadFormat"},{"location":"api/#pyunifiprotect.data.Sensor","text":"Bases: ProtectAdoptableDeviceModel","title":"Sensor"},{"location":"api/#pyunifiprotect.data.devices.Sensor.camera","text":"Paired Camera will always be none if no camera is paired","title":"camera()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.clear_tamper","text":"Clears tamper status for sensor","title":"clear_tamper()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.remove_humidity_safe_range","text":"Removes the humidity safe range for the sensor","title":"remove_humidity_safe_range()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.remove_light_safe_range","text":"Removes the light safe range for the sensor","title":"remove_light_safe_range()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.remove_temperature_safe_range","text":"Removes the temperature safe range for the sensor","title":"remove_temperature_safe_range()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_alarm_status","text":"Sets the alarm detection type for the sensor","title":"set_alarm_status()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_humidity_safe_range","text":"Sets the humidity safe range for the sensor","title":"set_humidity_safe_range()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_humidity_status","text":"Sets the humidity detection type for the sensor","title":"set_humidity_status()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_light_safe_range","text":"Sets the light safe range for the sensor","title":"set_light_safe_range()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_light_status","text":"Sets the light detection type for the sensor","title":"set_light_status()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_motion_sensitivity","text":"Sets the motion sensitivity for the sensor","title":"set_motion_sensitivity()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_motion_status","text":"Sets the motion detection type for the sensor","title":"set_motion_status()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_mount_type","text":"Sets current mount type for sensor","title":"set_mount_type()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_paired_camera","text":"Sets the camera paired with the sensor","title":"set_paired_camera()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_status_light","text":"Sets the status indicator light for the sensor","title":"set_status_light()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_temperature_safe_range","text":"Sets the temperature safe range for the sensor","title":"set_temperature_safe_range()"},{"location":"api/#pyunifiprotect.data.devices.Sensor.set_temperature_status","text":"Sets the temperature detection type for the sensor","title":"set_temperature_status()"},{"location":"api/#pyunifiprotect.data.User","text":"Bases: ProtectModelWithId","title":"User"},{"location":"api/#pyunifiprotect.data.user.User.can","text":"Checks if a user can do a specific action","title":"can()"},{"location":"api/#pyunifiprotect.data.user.User.groups","text":"Groups the user is in Will always be empty if the user only has read only access.","title":"groups()"},{"location":"api/#pyunifiprotect.data.Viewer","text":"Bases: ProtectAdoptableDeviceModel","title":"Viewer"},{"location":"api/#pyunifiprotect.data.devices.Viewer.set_liveview","text":"Sets the liveview current set for the viewer Parameters: Name Type Description Default liveview Liveview The liveview you want to set required","title":"set_liveview()"},{"location":"api/#pyunifiprotect.data.create_from_unifi_dict","text":"Helper method to read the modelKey from a UFP JSON dict and convert to currect Python class. Will raise DataDecodeError if the modelKey is for an unknown object.","title":"create_from_unifi_dict()"},{"location":"api/#exceptions-pyunifiprotectexception","text":"","title":"Exceptions (pyunifiprotect.exception)"},{"location":"api/#pyunifiprotect.exceptions.BadRequest","text":"Bases: ClientError Invalid request from API Client","title":"BadRequest"},{"location":"api/#pyunifiprotect.exceptions.ClientError","text":"Bases: UnifiProtectError Base Class for all other UniFi Protect client errors","title":"ClientError"},{"location":"api/#pyunifiprotect.exceptions.DataDecodeError","text":"Bases: UnifiProtectError Exception raised when trying to decode a UniFi Protect object","title":"DataDecodeError"},{"location":"api/#pyunifiprotect.exceptions.Invalid","text":"Bases: ClientError Invalid return from Authorization Request.","title":"Invalid"},{"location":"api/#pyunifiprotect.exceptions.NotAuthorized","text":"Bases: PermissionError , BadRequest Wrong username, password or permission error.","title":"NotAuthorized"},{"location":"api/#pyunifiprotect.exceptions.NvrError","text":"Bases: ClientError Other error.","title":"NvrError"},{"location":"api/#pyunifiprotect.exceptions.StreamError","text":"Bases: UnifiProtectError Expcetion raised when trying to stream content","title":"StreamError"},{"location":"api/#pyunifiprotect.exceptions.UnifiProtectError","text":"Bases: Exception Base class for all other UniFi Protect errors","title":"UnifiProtectError"},{"location":"api/#pyunifiprotect.exceptions.WSDecodeError","text":"Bases: UnifiProtectError Exception raised when decoding Websocket packet","title":"WSDecodeError"},{"location":"api/#pyunifiprotect.exceptions.WSEncodeError","text":"Bases: UnifiProtectError Exception raised when encoding Websocket packet","title":"WSEncodeError"},{"location":"api/#stream-pyunifiprotectstream","text":"","title":"Stream (pyunifiprotect.stream)"},{"location":"api/#utils-pyunifiprotectutils","text":"","title":"Utils (pyunifiprotect.utils)"},{"location":"api/#pyunifiprotect.utils.convert_smart_audio_types","text":"Converts list of str into SmartDetectAudioType. Any unknown values will be ignored and logged.","title":"convert_smart_audio_types()"},{"location":"api/#pyunifiprotect.utils.convert_smart_types","text":"Converts list of str into SmartDetectObjectType. Any unknown values will be ignored and logged.","title":"convert_smart_types()"},{"location":"api/#pyunifiprotect.utils.convert_unifi_data","text":"Converts value from UFP data into pydantic field class","title":"convert_unifi_data()"},{"location":"api/#pyunifiprotect.utils.convert_video_modes","text":"Converts list of str into VideoMode. Any unknown values will be ignored and logged.","title":"convert_video_modes()"},{"location":"api/#pyunifiprotect.utils.decode_token_cookie","text":"Decode a token cookie if it is still valid.","title":"decode_token_cookie()"},{"location":"api/#pyunifiprotect.utils.format_datetime","text":"Formats a datetime object in a consisent format","title":"format_datetime()"},{"location":"api/#pyunifiprotect.utils.format_duration","text":"Formats a timedelta as a string.","title":"format_duration()"},{"location":"api/#pyunifiprotect.utils.from_js_time","text":"Converts Javascript timestamp to Python datetime","title":"from_js_time()"},{"location":"api/#pyunifiprotect.utils.get_local_timezone","text":"Gets Olson timezone name for localizing datetimes","title":"get_local_timezone()"},{"location":"api/#pyunifiprotect.utils.is_debug","text":"Returns if debug ENV is on (True)","title":"is_debug()"},{"location":"api/#pyunifiprotect.utils.local_datetime","text":"Returns datetime in local timezone","title":"local_datetime()"},{"location":"api/#pyunifiprotect.utils.process_datetime","text":"Extracts datetime object from Protect dictionary","title":"process_datetime()"},{"location":"api/#pyunifiprotect.utils.serialize_coord","text":"Serializes UFP zone coordinate","title":"serialize_coord()"},{"location":"api/#pyunifiprotect.utils.serialize_dict","text":"Serializes UFP data dict","title":"serialize_dict()"},{"location":"api/#pyunifiprotect.utils.serialize_list","text":"Serializes UFP data list","title":"serialize_list()"},{"location":"api/#pyunifiprotect.utils.serialize_point","text":"Serializes UFP zone coordinate point","title":"serialize_point()"},{"location":"api/#pyunifiprotect.utils.serialize_unifi_obj","text":"Serializes UFP data","title":"serialize_unifi_obj()"},{"location":"api/#pyunifiprotect.utils.set_debug","text":"Sets ENV variable for UFP_DEBUG to on (True)","title":"set_debug()"},{"location":"api/#pyunifiprotect.utils.set_no_debug","text":"Sets ENV variable for UFP_DEBUG to off (False)","title":"set_no_debug()"},{"location":"api/#pyunifiprotect.utils.to_camel_case","text":"Converts string to camelCase","title":"to_camel_case()"},{"location":"api/#pyunifiprotect.utils.to_js_time","text":"Converts Python datetime to Javascript timestamp","title":"to_js_time()"},{"location":"api/#pyunifiprotect.utils.to_ms","text":"Converts python timedelta to Milliseconds","title":"to_ms()"},{"location":"api/#pyunifiprotect.utils.to_snake_case","text":"Converts string to snake_case","title":"to_snake_case()"},{"location":"api/#websocket-pyunifiprotectwebsocket","text":"","title":"Websocket (pyunifiprotect.websocket)"},{"location":"api/#pyunifiprotect.websocket.Websocket","text":"","title":"Websocket"},{"location":"api/#pyunifiprotect.websocket.Websocket.connect","text":"Connect the websocket.","title":"connect()"},{"location":"api/#pyunifiprotect.websocket.Websocket.disconnect","text":"Disconnect the websocket.","title":"disconnect()"},{"location":"api/#pyunifiprotect.websocket.Websocket.is_connected","text":"Is Websocket connected","title":"is_connected()"},{"location":"api/#pyunifiprotect.websocket.Websocket.reconnect","text":"Reconnect the websocket.","title":"reconnect()"},{"location":"api/#pyunifiprotect.websocket.Websocket.subscribe","text":"Subscribe to raw websocket messages. Returns a callback that will unsubscribe.","title":"subscribe()"},{"location":"cli/","text":"Command Line \u00b6 The unifi-protect command is provided to give a CLI interface to interact with your UniFi Protect instance as well. All commands support JSON output so it works great with jq for complex scripting. Authentication \u00b6 Following traditional twelve factor app design , the preferred way to provided authentication credentials to provided environment variables, but CLI args are also supported. About Ubiquiti SSO accounts Ubiquiti SSO accounts are not supported and actively discouraged from being used. There is no option to use MFA. You are expected to use local access user. pyunifiprotect is not designed to allow you to use your owner account to access the your console or to be used over the public Internet as both pose a security risk. Environment Variables \u00b6 Bash 1 2 3 4 5 6 7 8 export UFP_USERNAME = YOUR_USERNAME_HERE export UFP_PASSWORD = YOUR_PASSWORD_HERE export UFP_ADDRESS = YOUR_IP_ADDRESS export UFP_PORT = 443 # change to false if you do not have a valid HTTPS Certificate for your instance export UFP_SSL_VERIFY = True unifi-protect nvr CLI Args \u00b6 Bash 1 unifi-protect -U YOUR_USERNAME_HERE -P YOUR_PASSWORD_HERE -a YOUR_IP_ADDRESS -p 443 --no-verify nvr Timezones \u00b6 A number of commands allow you to enter a datetime as an argument or output files with the datetime in the filename. As a result, it is very important for pyunifiprotect to know your consoles local timezone. If you on a physical machine (not docker/VM), chances are this is already set up correctly for you ( /etc/localtime ), but otherwise you may need to set the TZ environment variable. TZ can also be used to override your system timezone as well if for whatever reason you need to. It should be the Olson timezone name for the timezone that your UniFi Protect Instance is in. Bash 1 TZ = America/New_York unifi-protect --help Note If for whatever reason your system does not have then correct timezone data, you can install the tz extra to get the data. This just adds the package tzdata as a requirement. It is included by default in the Docker image . Bash 1 pip install pyunifiprotect [ tz ] Reference \u00b6 Bash 1 2 3 4 $ unifi-protect --help Usage: unifi-protect [ OPTIONS ] COMMAND [ ARGS ] ... UniFi Protect CLI Options \u00b6 Option Required? Env Type Default Description -U --username UFP_USERNAME text UniFi Protect username -P --password UFP_PASSWORD text UniFi Protect password -a --address UFP_ADDRESS text UniFi Protect IP address or hostname -p --port UFP_PORT integer 443 UniFi Protect port --no-verify UFP_SSL_VERIFY boolean True Verify SSL --output-format json , plain plain Preferred output format. Not all commands support both JSON and plain and may still output in one or the other. -u --include-unadopted Include devices not adopted by this NVR. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show help message and exit. Subcommands \u00b6 For any subcommand you can use unifi-protect COMMAND --help Command Description backup Backup CLI . cameras Camera device CLI. chimes Chime device CLI. decode-ws-msg Decodes a base64 encoded UniFi Protect Websocket binary message. doorlocks Doorlock device CLI. events Events CLI. generate-sample-data Generates sample data for UniFi Protect instance. lights Lights device CLI. liveviews Liveviews CLI. nvr NVR device CLI. profile-ws Profiles Websocket messages for UniFi Protect instance. sensors Sensors device CLI. shell Opens iPython shell with Protect client initialized. viewers Viewers device CLI. Multiple Item CLI Commands \u00b6 All adoptable device CLIs, event and liveview CLI work on the idea you have multiple cameras, multiple lights, multiple events or multiple liveviews. As such, they have four variations: Bash 1 2 3 4 5 6 7 8 9 10 11 # list all devices (or events/liveviews) unifi-protect cameras # list short list of all devices (or events/liveviews) unifi-protect cameras list-ids # list a specific device (or event/liveview) unifi-protect cameras DEVICE_ID # run a command against a specific device (or event/liveview) unifi-protect cameras DEVICE_ID COMMAND Note The \"list all devices\" and \"list a specific device\" commands always return raw JSON. These commands can be paired with jq to parse and quick extra device data from them. Command Description list-ids Requires no device ID. Prints list of \"id name\" for each device. Examples \u00b6 List All Cameras \u00b6 Plain JSON Bash 1 2 3 4 5 $ unifi-protect cameras list-ids 61b3f5c7033ea703e7000424: G4 Bullet 61f9824e004adc03e700132c: G4 PTZ 61be1d2f004bda03e700ab12: G4 Dome Bash 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 $ unifi-protect --output-format json cameras list-ids [ [ \"61b3f5c7033ea703e7000424\" , \"G4 Bullet\" ] , [ \"61f9824e004adc03e700132c\" , \"G4 PTZ\" ] , [ \"61be1d2f004bda03e700ab12\" , \"G4 Done\" ] , ... ] Check if a Light is Online \u00b6 Bash 1 2 $ unifi-protect cameras 61ddb66b018e2703e7008c19 | jq .isConnected true Take Snapshot of Camera \u00b6 Bash 1 $ unifi-protect cameras 61ddb66b018e2703e7008c19 save-snapshot output.jpg Adoptable Devices CLI Commands \u00b6 Adoptable devices (Cameras, Chimes, Doorlocks, Lights, Sensors, Viewers) all have some commands in common. Command Description adopt Adopts a device. bridge Returns bridge device if connected via Bluetooth. is-bluetooth Returns if the device has Bluetooth or not. is-wifi Returns if the device has WiFi or not. is-wired Returns if the device is wired or not. protect-url Gets UniFi Protect management URL. reboot Reboots the device. unadopt Unadopt/Unmanage adopted device. update Updates the device. Backup CLI \u00b6 Bash 1 2 3 4 5 6 $ unifi-protect backup --help Usage: unifi-protect backup [ OPTIONS ] COMMAND [ ARGS ] ... Backup CLI. The backup CLI is still very WIP in progress and consider experimental and potentially unstable ( interface may change in the future ) . Backup Options \u00b6 Option Env Type Default Description -s --start UFP_BACKUP_START datetime Cutoff for start of backup. Defaults to start of recording for NVR. -e --end UFP_BACKUP_END datetime Cutoff for end of backup. Defaults to now. --output-folder UFP_BACKUP_OUTPUT path $PWD Base dir for creating files. Defaults to $PWD. --thumb-format text {year}/{month}/{day}/{hour}/{datetime}{sep}{mac}{sep}{camera_slug}{event_type}{sep}thumb.jpg Filename format to save event thumbnails to. Set to empty string (\"\") to skip saving event thumbnails. --gif-format text {year}/{month}/{day}/{hour}/{datetime}{sep}{mac}{sep}{camera_slug}{event_type}{sep}animated.gif] Filename format to save event gifs to. Set to empty string (\"\") to skip saving event gif. --event-format text {year}/{month}/{day}/{hour}/{datetime}{sep}{mac}{sep}{camera_slug}{event_type}.mp4 Filename format to save event gifs to. Set to empty string (\"\") to skip saving event videos. --title-format text {time_sort_pretty_local} {sep} {camera_name} {sep} {event_type_pretty} {sep} {length_pretty} Format to use to tag title for video metadata. -v --verbose boolean False Debug logging. -d --max-download integer 5 Max number of concurrent downloads. Adds additional loads to NVR. --page-size integer 1000 Number of events fetched at once from local database. Increases memory usage. --length-cutoff integer 3600 Event size cutoff for detecting abnormal events (in seconds). --sep boolean - Separator used for formatting. --help Show help message and exit. File Name and Title Formatting \u00b6 There are 5 options controlling output format for file names and metadata. This allows you to customize backups to your liking. All 5 options are a template string. Here are all of the available templating variables: Variable Description year UTC year of start of export. month UTC month of start of export. day UTC day of start of export. hour UTC hour of start of export. minute UTC minute of start of export. datetime ISO 8601 formatted UTC datetime of start of export. Uses sep between parts. date ISO 8601 formatted UTC date of start of export. Uses sep between parts. time UTC time of start of export. Uses sep between parts. 24 hour time. time_sort_pretty UTC time of start of export. Uses : between parts. 24 hour time. time_pretty UTC time of start of export. Uses : between parts. 12 hour time with AM/PM. year_local Local year of start of export. month_local Local month of start of export. day_local Local day of start of export. hour_local Local hour of start of export. minute_local Local minute of start of export. datetime_local ISO 8601 formatted Local datetime of start of export. Uses sep between parts. date_local ISO 8601 formatted Local date of start of export. Uses sep between parts. time_local Local time of start of export. Uses sep between parts. 24 hour time. time_sort_pretty_local Local time of start of export. Uses : between parts. 24 hour time. time_pretty_local Local time of start of export. Uses : between parts. 12 hour time with AM/PM. mac MAC address of camera. camera_name Name of camera. camera_slug Lowercased name of camera with spaces replaced with sep . event_type Lowercased name of the event exported. event_type_pretty More human readable name of event exported. length_pretty Human readable version of the length of the clip exported. sep Separator to use in many cases. Datetimes \u00b6 All datetimes for the Backup CLi can either be in ISO 8601 format or can be a human readable format that the Python library dateparse can understand. This will allow relative datetimes to be passed, such as \"1 hour ago\" which will make backing up incremental for cron jobs. Formatting for Plex \u00b6 You are able to export your Camera events and then access them in Plex relatively well. For setup in Plex, the following is recommended: Enable the \"Local Media Assets\" Agent Source for the Movies Library Type (Settings -> Agents -> Movies). Plex docs . Create a \"Other Videos\" library pointing to the same folder as your --output-folder folder. Scanner: \"Plex Video Files Scanner\" Agent: \"Personal Media\" Recommended formats for the backup command: Option Format --thumb-format {year_local}/{month_local}/{day_local}/{hour_local}/{title}.jpg --gif-format {year_local}/{month_local}/{day_local}/{hour_local}/{title}.gif --event-format {year_local}/{month_local}/{day_local}/{hour_local}/{title}.mp4 --title-format default or whatever you want the title to be in Plex. Backing Up Camera Events \u00b6 Bash 1 2 3 4 5 $ unifi-protect backup events --help Usage: unifi-protect backup events [ OPTIONS ] Backup thumbnails and video clips for camera events. Option Type Default Description -t --event-type motion , ring , smartDetectZone motion , ring , smartDetectZone Events to export. Can be used multiple time. -m --smart-type person , vehicle , package person , vehicle , package Smart Detection types to export. Can be used multiple time. -p --prune boolean False Prune events older then start. -f --force boolean False Force update all events and redownload all clips. -v --verify boolean False Verifies files on disk. --no-input boolean False Disables confirmation prompt if -p and -f both passed. --help Show help message and exit. The backup events command essentially mirrors all of the selected events from your UniFi Protect instance into a local sqlite database ( events.db inside of the --output-folder ). As a result, the initial run make take a really long time to run if your UniFi Protect instance has a lot of events inside of it. As an example using a UniFi Protect instance with ~200k events and ~8 months of camera footage: Building the database is in the range of hours Doing the initial download of event thumbnails, gifs and video clips is in the range of tens of hours (potentially 1-2 days) Incremental or targeted backups are much faster (<1 per event) Cron Usage For incremental backups in crons, it is recommended you run the command with an absolute start first to build your events database and do an initial download of files. This will significantly speed up the incremental backup commands. Examples \u00b6 Backup All Events \u00b6 Bash 1 unifi-protect backup events Backup All Smart Detections for the Past Hour \u00b6 Bash 1 unifi-protect backup --start \"1 hour ago\" events -t smartDetectZone Backup All Person Smart Detections from December 31st at 10PM to January 1st at 5AM \u00b6 Bash 1 unifi-protect backup --start \"2021-12-31T22:00:00\" --end \"2022-1-1T05:00:00\" events -t smartDetectZone -m person Camera CLI \u00b6 Inherits Multiple Item CLI Commands and Adoptable Devices CLI Commands . Examples \u00b6 Take Snapshot of Camera \u00b6 Bash 1 $ unifi-protect cameras 61ddb66b018e2703e7008c19 save-snapshot output.jpg Export Video From Camera \u00b6 Bash 1 $ unifi-protect cameras 61ddb66b018e2703e7008c19 save-video export.mp4 2022 -6-1T00:00:00 2022 -6-1T00:00:30 Timezones See the section on Timezones for determined what timezone your datetimes are in. Play Audio File to Cameras Speaker \u00b6 Bash 1 $ unifi-protect cameras 61ddb66b018e2703e7008c19 play-audio test.mp3 Include Unadopted Cameras in list \u00b6 Bash 1 $ unifi-protect -u cameras list-ids Adopt an Unadopted Camera \u00b6 Bash 1 $ unifi-protect -u cameras 61ddb66b018e2703e7008c19 adopt Enable SSH on Camera \u00b6 Bash 1 2 3 4 5 $ unifi-protect cameras 61ddb66b018e2703e7008c19 set-ssh true # get current value to verify $ unifi-protect cameras 61ddb66b018e2703e7008c19 | jq .isSshEnabled true Reboot Camera \u00b6 Bash 1 $ unifi-protect lights 61b3f5c801f8a703e7000428 reboot Reboot All Cameras \u00b6 Bash 1 2 3 for id in $( unifi-protect cameras list-ids | awk '{ print $1 }' ) ; do unifi-protect cameras $id reboot done Chime CLI \u00b6 Inherits Multiple Item CLI Commands and Adoptable Devices CLI Commands . Examples \u00b6 Set Paired Cameras \u00b6 Bash 1 $ unifi-protect chimes 6275b22e00e3c403e702a019 cameras 61ddb66b018e2703e7008c19 61f9824e004adc03e700132c","title":"Command Line"},{"location":"cli/#command-line","text":"The unifi-protect command is provided to give a CLI interface to interact with your UniFi Protect instance as well. All commands support JSON output so it works great with jq for complex scripting.","title":"Command Line"},{"location":"cli/#authentication","text":"Following traditional twelve factor app design , the preferred way to provided authentication credentials to provided environment variables, but CLI args are also supported. About Ubiquiti SSO accounts Ubiquiti SSO accounts are not supported and actively discouraged from being used. There is no option to use MFA. You are expected to use local access user. pyunifiprotect is not designed to allow you to use your owner account to access the your console or to be used over the public Internet as both pose a security risk.","title":"Authentication"},{"location":"cli/#environment-variables","text":"Bash 1 2 3 4 5 6 7 8 export UFP_USERNAME = YOUR_USERNAME_HERE export UFP_PASSWORD = YOUR_PASSWORD_HERE export UFP_ADDRESS = YOUR_IP_ADDRESS export UFP_PORT = 443 # change to false if you do not have a valid HTTPS Certificate for your instance export UFP_SSL_VERIFY = True unifi-protect nvr","title":"Environment Variables"},{"location":"cli/#cli-args","text":"Bash 1 unifi-protect -U YOUR_USERNAME_HERE -P YOUR_PASSWORD_HERE -a YOUR_IP_ADDRESS -p 443 --no-verify nvr","title":"CLI Args"},{"location":"cli/#timezones","text":"A number of commands allow you to enter a datetime as an argument or output files with the datetime in the filename. As a result, it is very important for pyunifiprotect to know your consoles local timezone. If you on a physical machine (not docker/VM), chances are this is already set up correctly for you ( /etc/localtime ), but otherwise you may need to set the TZ environment variable. TZ can also be used to override your system timezone as well if for whatever reason you need to. It should be the Olson timezone name for the timezone that your UniFi Protect Instance is in. Bash 1 TZ = America/New_York unifi-protect --help Note If for whatever reason your system does not have then correct timezone data, you can install the tz extra to get the data. This just adds the package tzdata as a requirement. It is included by default in the Docker image . Bash 1 pip install pyunifiprotect [ tz ]","title":"Timezones"},{"location":"cli/#reference","text":"Bash 1 2 3 4 $ unifi-protect --help Usage: unifi-protect [ OPTIONS ] COMMAND [ ARGS ] ... UniFi Protect CLI","title":"Reference"},{"location":"cli/#options","text":"Option Required? Env Type Default Description -U --username UFP_USERNAME text UniFi Protect username -P --password UFP_PASSWORD text UniFi Protect password -a --address UFP_ADDRESS text UniFi Protect IP address or hostname -p --port UFP_PORT integer 443 UniFi Protect port --no-verify UFP_SSL_VERIFY boolean True Verify SSL --output-format json , plain plain Preferred output format. Not all commands support both JSON and plain and may still output in one or the other. -u --include-unadopted Include devices not adopted by this NVR. --show-completion Show completion for the current shell, to copy it or customize the installation. --help Show help message and exit.","title":"Options"},{"location":"cli/#subcommands","text":"For any subcommand you can use unifi-protect COMMAND --help Command Description backup Backup CLI . cameras Camera device CLI. chimes Chime device CLI. decode-ws-msg Decodes a base64 encoded UniFi Protect Websocket binary message. doorlocks Doorlock device CLI. events Events CLI. generate-sample-data Generates sample data for UniFi Protect instance. lights Lights device CLI. liveviews Liveviews CLI. nvr NVR device CLI. profile-ws Profiles Websocket messages for UniFi Protect instance. sensors Sensors device CLI. shell Opens iPython shell with Protect client initialized. viewers Viewers device CLI.","title":"Subcommands"},{"location":"cli/#multiple-item-cli-commands","text":"All adoptable device CLIs, event and liveview CLI work on the idea you have multiple cameras, multiple lights, multiple events or multiple liveviews. As such, they have four variations: Bash 1 2 3 4 5 6 7 8 9 10 11 # list all devices (or events/liveviews) unifi-protect cameras # list short list of all devices (or events/liveviews) unifi-protect cameras list-ids # list a specific device (or event/liveview) unifi-protect cameras DEVICE_ID # run a command against a specific device (or event/liveview) unifi-protect cameras DEVICE_ID COMMAND Note The \"list all devices\" and \"list a specific device\" commands always return raw JSON. These commands can be paired with jq to parse and quick extra device data from them. Command Description list-ids Requires no device ID. Prints list of \"id name\" for each device.","title":"Multiple Item CLI Commands"},{"location":"cli/#examples","text":"","title":"Examples"},{"location":"cli/#adoptable-devices-cli-commands","text":"Adoptable devices (Cameras, Chimes, Doorlocks, Lights, Sensors, Viewers) all have some commands in common. Command Description adopt Adopts a device. bridge Returns bridge device if connected via Bluetooth. is-bluetooth Returns if the device has Bluetooth or not. is-wifi Returns if the device has WiFi or not. is-wired Returns if the device is wired or not. protect-url Gets UniFi Protect management URL. reboot Reboots the device. unadopt Unadopt/Unmanage adopted device. update Updates the device.","title":"Adoptable Devices CLI Commands"},{"location":"cli/#backup-cli","text":"Bash 1 2 3 4 5 6 $ unifi-protect backup --help Usage: unifi-protect backup [ OPTIONS ] COMMAND [ ARGS ] ... Backup CLI. The backup CLI is still very WIP in progress and consider experimental and potentially unstable ( interface may change in the future ) .","title":"Backup CLI"},{"location":"cli/#backup-options","text":"Option Env Type Default Description -s --start UFP_BACKUP_START datetime Cutoff for start of backup. Defaults to start of recording for NVR. -e --end UFP_BACKUP_END datetime Cutoff for end of backup. Defaults to now. --output-folder UFP_BACKUP_OUTPUT path $PWD Base dir for creating files. Defaults to $PWD. --thumb-format text {year}/{month}/{day}/{hour}/{datetime}{sep}{mac}{sep}{camera_slug}{event_type}{sep}thumb.jpg Filename format to save event thumbnails to. Set to empty string (\"\") to skip saving event thumbnails. --gif-format text {year}/{month}/{day}/{hour}/{datetime}{sep}{mac}{sep}{camera_slug}{event_type}{sep}animated.gif] Filename format to save event gifs to. Set to empty string (\"\") to skip saving event gif. --event-format text {year}/{month}/{day}/{hour}/{datetime}{sep}{mac}{sep}{camera_slug}{event_type}.mp4 Filename format to save event gifs to. Set to empty string (\"\") to skip saving event videos. --title-format text {time_sort_pretty_local} {sep} {camera_name} {sep} {event_type_pretty} {sep} {length_pretty} Format to use to tag title for video metadata. -v --verbose boolean False Debug logging. -d --max-download integer 5 Max number of concurrent downloads. Adds additional loads to NVR. --page-size integer 1000 Number of events fetched at once from local database. Increases memory usage. --length-cutoff integer 3600 Event size cutoff for detecting abnormal events (in seconds). --sep boolean - Separator used for formatting. --help Show help message and exit.","title":"Backup Options"},{"location":"cli/#file-name-and-title-formatting","text":"There are 5 options controlling output format for file names and metadata. This allows you to customize backups to your liking. All 5 options are a template string. Here are all of the available templating variables: Variable Description year UTC year of start of export. month UTC month of start of export. day UTC day of start of export. hour UTC hour of start of export. minute UTC minute of start of export. datetime ISO 8601 formatted UTC datetime of start of export. Uses sep between parts. date ISO 8601 formatted UTC date of start of export. Uses sep between parts. time UTC time of start of export. Uses sep between parts. 24 hour time. time_sort_pretty UTC time of start of export. Uses : between parts. 24 hour time. time_pretty UTC time of start of export. Uses : between parts. 12 hour time with AM/PM. year_local Local year of start of export. month_local Local month of start of export. day_local Local day of start of export. hour_local Local hour of start of export. minute_local Local minute of start of export. datetime_local ISO 8601 formatted Local datetime of start of export. Uses sep between parts. date_local ISO 8601 formatted Local date of start of export. Uses sep between parts. time_local Local time of start of export. Uses sep between parts. 24 hour time. time_sort_pretty_local Local time of start of export. Uses : between parts. 24 hour time. time_pretty_local Local time of start of export. Uses : between parts. 12 hour time with AM/PM. mac MAC address of camera. camera_name Name of camera. camera_slug Lowercased name of camera with spaces replaced with sep . event_type Lowercased name of the event exported. event_type_pretty More human readable name of event exported. length_pretty Human readable version of the length of the clip exported. sep Separator to use in many cases.","title":"File Name and Title Formatting"},{"location":"cli/#backing-up-camera-events","text":"Bash 1 2 3 4 5 $ unifi-protect backup events --help Usage: unifi-protect backup events [ OPTIONS ] Backup thumbnails and video clips for camera events. Option Type Default Description -t --event-type motion , ring , smartDetectZone motion , ring , smartDetectZone Events to export. Can be used multiple time. -m --smart-type person , vehicle , package person , vehicle , package Smart Detection types to export. Can be used multiple time. -p --prune boolean False Prune events older then start. -f --force boolean False Force update all events and redownload all clips. -v --verify boolean False Verifies files on disk. --no-input boolean False Disables confirmation prompt if -p and -f both passed. --help Show help message and exit. The backup events command essentially mirrors all of the selected events from your UniFi Protect instance into a local sqlite database ( events.db inside of the --output-folder ). As a result, the initial run make take a really long time to run if your UniFi Protect instance has a lot of events inside of it. As an example using a UniFi Protect instance with ~200k events and ~8 months of camera footage: Building the database is in the range of hours Doing the initial download of event thumbnails, gifs and video clips is in the range of tens of hours (potentially 1-2 days) Incremental or targeted backups are much faster (<1 per event) Cron Usage For incremental backups in crons, it is recommended you run the command with an absolute start first to build your events database and do an initial download of files. This will significantly speed up the incremental backup commands.","title":"Backing Up Camera Events"},{"location":"cli/#examples_1","text":"","title":"Examples"},{"location":"cli/#camera-cli","text":"Inherits Multiple Item CLI Commands and Adoptable Devices CLI Commands .","title":"Camera CLI"},{"location":"cli/#examples_2","text":"","title":"Examples"},{"location":"cli/#chime-cli","text":"Inherits Multiple Item CLI Commands and Adoptable Devices CLI Commands .","title":"Chime CLI"},{"location":"cli/#examples_3","text":"","title":"Examples"},{"location":"dev/","text":"Development \u00b6 Setup \u00b6 With VS Code \u00b6 Development with this project is designed to be done via VS Code + Docker. It is a pretty standard Python package, so feel free to use anything else, but all documentation assumes you are using VS Code. VS Code + Remote Containers extension Docker If you are using Linux, you need Docker Engine 19.0 or newer and you need to enable Docker Buildkit If you are using Docker Desktop on MacOS or Windows, you will need Docker Desktop 3.2.0 or newer Once you have all three setup, Clone repo Open the main folder You should be prompted to \"Reopen folder to develop in a container\". If you are not, you can open the Command Palette run the \"Remote-Containers: Reopen in Container\" command. This should be all you need to do to get a working development environment. The docker container will automatically be build and VS Code will attach itself to it. The integrated terminal in VS Code will already be set up with the unifi-protect command. Docker (without VS Code) \u00b6 You can still setup develop without VS Code, but it is still recommended to use the development container to ensure you have all of the required dependancies. As a result, the above requirement for Docker is still needed. Once you have Docker setup, Clone repo Build and open dev container Bash 1 2 docker buildx build -f Dockerfile --target = dev -t pyunifiprotect-dev . docker run --rm -it -v /home/cbailey/dev/pyunifiprotect:/workspaces/pyunifiprotect pyunifiprotect-dev bash Authenticating with your Local Protect Instance \u00b6 The project allows you to create an environment file to put your local protect instance data into so you do not need to constantly enter in or accidentally commit it to the Git repo. Make a file in the root of the project named .env with the following and change accordingly: Text Only 1 2 3 4 5 6 UFP_USERNAME=YOUR_USERNAME_HERE UFP_PASSWORD=YOUR_PASSWORD_HERE UFP_ADDRESS=YOUR_IP_ADDRESS UFP_PORT=443 # change to false if you do not have a valid HTTPS Certificate for your instance UFP_SSL_VERIFY=True Linting and Testing \u00b6 The following scripts exist to easily format, lint and test code in the same fashion as CI: Text Only 1 2 3 .bin/format-code .bin/lint-code .bin/test-code These commands are also all available as VS Code tasks as well. Tests are also fully integration with the Testing panel in VS Code and can be easily debug from there. Updating Requirements \u00b6 To generate an updated pinned requirements file to be used for testing and CI using the .bin/update-requirements script. There is also a VS Code task to run this as well. Generating Test Data \u00b6 All of the tests in the project are ran against that is generated from a real UniFi Protect instance and then anonymized so it is safe to commit to a Git repo. To generate new sample test data: Text Only 1 unifi-protect generate-sample-data This will gather test data for 30 seconds and write it all into the tests/sample_data directory. During this time, it is a good idea to generate some good events that can tested. An example would be to generate a motion event for a FloodLight, Camera and/or Doorbell and then also ring a Doorbell. All of the data that is generated is automatically anonymized so nothing sensitive about your NVR is exposed. To skip anonymization, use the --actual option. To change output directory for sample data use the -o / --output option. To adjust the time adjust how long to wait for Websocket messages, use the -w / --wait option. To automatically zip up the generated sample data, use the --zip option. Bash 1 2 export UFP_SAMPLE_DIR = /workspaces/pyunifiprotect/test-data unifi-protect generate-sample-data Real Data in Tests \u00b6 pytest will automatically also use the UFP_SAMPLE_DIR environment variable to locate sample data for running tests. This allows you to run pytest against a real NVR instance. Bash 1 2 export UFP_SAMPLE_DIR = /workspaces/pyunifiprotect/test-data pytest","title":"Development"},{"location":"dev/#development","text":"","title":"Development"},{"location":"dev/#setup","text":"","title":"Setup"},{"location":"dev/#with-vs-code","text":"Development with this project is designed to be done via VS Code + Docker. It is a pretty standard Python package, so feel free to use anything else, but all documentation assumes you are using VS Code. VS Code + Remote Containers extension Docker If you are using Linux, you need Docker Engine 19.0 or newer and you need to enable Docker Buildkit If you are using Docker Desktop on MacOS or Windows, you will need Docker Desktop 3.2.0 or newer Once you have all three setup, Clone repo Open the main folder You should be prompted to \"Reopen folder to develop in a container\". If you are not, you can open the Command Palette run the \"Remote-Containers: Reopen in Container\" command. This should be all you need to do to get a working development environment. The docker container will automatically be build and VS Code will attach itself to it. The integrated terminal in VS Code will already be set up with the unifi-protect command.","title":"With VS Code"},{"location":"dev/#docker-without-vs-code","text":"You can still setup develop without VS Code, but it is still recommended to use the development container to ensure you have all of the required dependancies. As a result, the above requirement for Docker is still needed. Once you have Docker setup, Clone repo Build and open dev container Bash 1 2 docker buildx build -f Dockerfile --target = dev -t pyunifiprotect-dev . docker run --rm -it -v /home/cbailey/dev/pyunifiprotect:/workspaces/pyunifiprotect pyunifiprotect-dev bash","title":"Docker (without VS Code)"},{"location":"dev/#authenticating-with-your-local-protect-instance","text":"The project allows you to create an environment file to put your local protect instance data into so you do not need to constantly enter in or accidentally commit it to the Git repo. Make a file in the root of the project named .env with the following and change accordingly: Text Only 1 2 3 4 5 6 UFP_USERNAME=YOUR_USERNAME_HERE UFP_PASSWORD=YOUR_PASSWORD_HERE UFP_ADDRESS=YOUR_IP_ADDRESS UFP_PORT=443 # change to false if you do not have a valid HTTPS Certificate for your instance UFP_SSL_VERIFY=True","title":"Authenticating with your Local Protect Instance"},{"location":"dev/#linting-and-testing","text":"The following scripts exist to easily format, lint and test code in the same fashion as CI: Text Only 1 2 3 .bin/format-code .bin/lint-code .bin/test-code These commands are also all available as VS Code tasks as well. Tests are also fully integration with the Testing panel in VS Code and can be easily debug from there.","title":"Linting and Testing"},{"location":"dev/#updating-requirements","text":"To generate an updated pinned requirements file to be used for testing and CI using the .bin/update-requirements script. There is also a VS Code task to run this as well.","title":"Updating Requirements"},{"location":"dev/#generating-test-data","text":"All of the tests in the project are ran against that is generated from a real UniFi Protect instance and then anonymized so it is safe to commit to a Git repo. To generate new sample test data: Text Only 1 unifi-protect generate-sample-data This will gather test data for 30 seconds and write it all into the tests/sample_data directory. During this time, it is a good idea to generate some good events that can tested. An example would be to generate a motion event for a FloodLight, Camera and/or Doorbell and then also ring a Doorbell. All of the data that is generated is automatically anonymized so nothing sensitive about your NVR is exposed. To skip anonymization, use the --actual option. To change output directory for sample data use the -o / --output option. To adjust the time adjust how long to wait for Websocket messages, use the -w / --wait option. To automatically zip up the generated sample data, use the --zip option. Bash 1 2 export UFP_SAMPLE_DIR = /workspaces/pyunifiprotect/test-data unifi-protect generate-sample-data","title":"Generating Test Data"},{"location":"dev/#real-data-in-tests","text":"pytest will automatically also use the UFP_SAMPLE_DIR environment variable to locate sample data for running tests. This allows you to run pytest against a real NVR instance. Bash 1 2 export UFP_SAMPLE_DIR = /workspaces/pyunifiprotect/test-data pytest","title":"Real Data in Tests"}]}